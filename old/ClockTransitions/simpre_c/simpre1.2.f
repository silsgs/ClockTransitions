c
      program simpre
c
      implicit double precision (a-h,o-z)
c
      include 'simpre.par'
c
      complex*16 zz(idtot,idtot)
c 
      dimension dd(idtot) 
      dimension plm(6,0:6)
      dimension g(13)
      dimension stev(6,13)
      dimension ro(6,13),rr(6,13)
      dimension z(ichar),z0(ichar)
      dimension xyz(3,ichar),xyz0(3,ichar)
      dimension rtp(3,ichar),rtp0(3,ichar)
      dimension isn(13)
      dimension isv(13)
c 
      character*7 ele(13)
c  
      common /rr133/ zz 
      common /rr132/ dd
      common /a592/ plm
      common /a500/ g
      common /a501/ stev
      common /a503/ ro,rr
      common /a603/ z,z0
      common /a600/ xyz,xyz0
      common /a602/ rtp,rtp0
      common /rr50/ temp1,temp2,field
      common /i550/ isteptemp
      common /i500/ isn
      common /i502/ isv
      common /i501/ inn
      common /ixxx/ nc
      common /c002/ ele
      common /RS99/ fclock
c
      open (3,file='simpre.out',status='unknown')
      ii = 3
c
      call lab(ii)
      call fak
      call lanta
c 
      call war
      call fun
      call operators
c
      call bkq
      call zee
c
      if (nmf.eq.1) then
        fclock=fieldstart
        call ene
        call esm
        open(14,FILE='simpre.mf.out',STATUS='unknown')
        call readwritedata
        call dec
        close(14)
c
      else
c
      if (ivar.eq.0) then
        fclock=fieldstart
        call ene
        call esm
        if (idec.eq.1) then
          open(10,FILE='simpre.t2.out',STATUS='unknown')
          call readwritedata
          call dec
          close(10)
        endif
        if(irot.eq.1) then
          open (5,file='simpre.coo',status='new')
          call rota
          close(5)
        endif
      else
        open(2,FILE='simpre.ene',STATUS='unknown')
        fclock=fieldstart
        if(idec.eq.1) then
          open(10,FILE='simpre.t2.out',STATUS='unknown')
          call readwritedata
        endif
        do while(fclock.lt.(fieldend+fieldstep))
          write (3,*) ' '
          write (3,*) '*******************************************'
          write (3,321) fclock
          write (3,*) '*******************************************'
          write (3,*) ' '
          call ene
          call esm
          if(idec.eq.1) then
            call dec
          endif
          write(2,320) fclock,(dd(ind),ind=1,imaxe)
          fclock=fclock+fieldstep
        end do
        close(10)
        close(2)
      endif
c
      endif
c
      if (isus.eq.1) then
        open (8,file='sus.out',status='unknown')
        ii = 8
        call lab(ii)
        call sus
        close(8)
      endif
c
      if (imag.eq.1) then
        open (9,file='mag.out',status='unknown')
        ii = 9
        call lab(ii)
        call mag
        close(9)
      endif
c
      close(3)
 320  format(f16.8,1000f16.6)
 321  format('     Magnetic Field (T) =',f9.5)
c
      stop
      end
c
      subroutine lab(ii)
c
      implicit double precision (a-h,o-z)
c
      write (ii,200)
      write (ii,201)
      write (ii,200)
      write (ii,*) 
      write (ii,*)'____________________________________________________'
      write (ii,*) 
      write (ii,*)'.######..####.##.....##.########..########..########'
      write (ii,*)'##....##..##..###...###.##.....##.##.....##.##......'
      write (ii,*)'##........##..####.####.##.....##.##.....##.##......'
      write (ii,*)'.######...##..##.###.##.########..########..######..'
      write (ii,*)'......##..##..##.....##.##........##...##...##......'
      write (ii,*)'##....##..##..##.....##.##........##....##..##......'
      write (ii,*)'.######..####.##.....##.##........##.....##.########'
      write (ii,*)'____________________________________________________'
      write (ii,*)                                             
      write (ii,*)'****************************************************'
      write (ii,*)                                              
c
 200  format ('******************************************************')
 201  format ('**  output file generated by SIMPRE version 1.2 **')
c
      return
      end
c
      subroutine fak
c
      implicit double precision (a-h,o-z)
c
      dimension fac(-1:60)
c
      common /rr180/ fac
c
      fac(-1)=1.d0
      fac(0)=1.d0
      fac(1)=1.d0
      din = 1.d0
      do 1 i=2,60
      din = din + 1.d0
      fac(i)=fac(i-1)*din
 1    continue
c
      return
      end
c
      subroutine lanta
c
      implicit double precision (a-h,o-z)
c
      include 'simpre.par'
c
      dimension plm(6,0:6)
      dimension g(13)
      dimension stev(6,13)
      dimension ro(6,13),rr(6,13)
      dimension isn(13)
      dimension isv(13)
      character*7 ele(13)
c
      common /a592/ plm
      common /a500/ g
      common /a501/ stev
      common /a503/ ro,rr
      common /a504/ pi
      common /i500/ isn
      common /i502/ isv
      common /i501/ inn
      common /c002/ ele
c       
      pi  = 3.141592653589793238462643383279d0             
c
      plm(2,0) = (1.d0/4.d0)*dsqrt(5.d0/pi)                
      plm(4,0) = (3.d0/16.d0)*dsqrt(1.d0/pi)               
      plm(6,0) = (1.d0/32.d0)*dsqrt(13.d0/pi)              
c                                                  
      plm(2,1) = (1.d0/2.d0)*dsqrt(15.d0/pi)               
      plm(4,1) = (3.d0/4.d0)*dsqrt(5.d0/(2.d0*pi))         
      plm(6,1) = (1.d0/8.d0)*dsqrt(273.d0/(4.d0*pi))       
c                                                          
      plm(2,2) = (1.d0/4.d0)*dsqrt(15.d0/pi)               
      plm(4,2) = (3.d0/8.d0)*dsqrt(5.d0/pi)                
      plm(6,2) = (1.d0/64.d0)*dsqrt(2730.d0/pi)            
c                                                          
      plm(4,3) = (3.d0/8.d0)*dsqrt(70.d0/pi) 
      plm(6,3) = (1.d0/32.d0)*dsqrt(2730.d0/pi) 
c                                                    
      plm(4,4) = (3.d0/16.d0)*dsqrt(35.d0/pi)              
      plm(6,4) = (21.d0/32.d0)*dsqrt(13.d0/(7.d0*pi))      
c                                                    
      plm(6,5) = dsqrt(9009.d0/(512.d0*pi))  
c                                                          
      plm(6,6) = (231.d0/64.d0)*dsqrt(26.d0/(231.d0*pi))
c
      isn(1) = 5
      isv(1) = 0
      g(1)   = 6.d0/7.d0
      stev(2,1) = -2.d0/35.d0
      stev(4,1) =  2.d0/(9.d0*35.d0)
      stev(6,1) =  0.d0
      ele(1)   ='Ce(III)'
      ro(2,1) = 0.51d0
      ro(4,1) = 0.0132d0
      ro(6,1) =-0.0294d0
      rr(2,1) = 1.456d0
      rr(4,1) = 5.437d0
      rr(6,1) = 42.26d0
c
      isn(2) = 8
      isv(2) = 5
      g(2)   = 4.d0/5.d0
      stev(2,2) = -4.d0*13.d0/(9.d0*25.d0*11.d0)
      stev(4,2) = -4.d0/(9.d0*5.d0*121.d0)
      stev(6,2) =  16.d0*17.d0/(81.d0*35.d0*121.d0*13.d0)
      ele(2)   ='Pr(III)'
      ro(2,2) = 0.515d0
      ro(4,2) = 0.0138d0
      ro(6,2) =-0.0301d0
      rr(2,2) = 1.327d0
      rr(4,2) = 4.537d0
      rr(6,2) = 32.65d0
c
      isn(3) = 9
      isv(3) = 7
      g(3)   = 8.d0/11.d0
      stev(2,3) = -7.d0/(9.d0*121.d0)
      stev(4,3) = -4.d0*17.d0/(27.d0*1331.d0*13.d0)
      stev(6,3) = -5.d0*17.d0*19.d0/(27.d0*7.d0*1331.d0*169.d0)
      ele(3)   ='Nd(III)'
      ro(2,3) = 0.518d0
      ro(4,3) = 0.013d0
      ro(6,3) =-0.031d0
      rr(2,3) = 1.222d0
      rr(4,3) = 3.875d0
      rr(6,3) = 26.12d0
c
      isn(4) = 8
      isv(4) = 0
      g(4)   = 3.d0/5.d0
      stev(2,4) = 14.d0/(35.d0*121.d0)
      stev(4,4) = 8.d0*7.d0*17.d0/(27.d0*5.d0*1331.d0*13.d0)
      stev(6,4) = 8.d0*17.d0*19.d0/(27.d0*7.d0*1331.d0*169.d0)
      ele(4)   ='Pm(III)'
      ro(2,4) = 0.519d0
      ro(4,4) = 0.0109d0
      ro(6,4) =-0.0314d0
      rr(2,4) = 1.135d0
      rr(4,4) = 3.366d0
      rr(6,4) = 21.46d0
c
      isn(5) = 5
      isv(5) = 7
      g(5)   = 2.d0/7.d0
      stev(2,5) = 13.d0/(9.d0*35.d0)
      stev(4,5) = 26.d0/(27.d0*35.d0*11.d0)
      stev(6,5) = 0.d0
      ele(5)   ='Sm(III)'
      ro(2,5) = 0.519d0
      ro(4,5) = 0.0077d0
      ro(6,5) =-0.0317d0
      rr(2,5) = 1.061d0
      rr(4,5) = 2.964d0
      rr(6,5) = 17.99d0
c
      isn(6) = 12
      isv(6) = 3 
      g(6)   = 3.d0/2.d0
      stev(2,6) =-1.d0/99.d0
      stev(4,6) = 2.d0/(11.d0*1485.d0)
      stev(6,6) =-1.d0/(13.d0*33.d0*2079.d0)
      ele(6)   ='Tb(III)'
      ro(2,6) = 0.523d0
      ro(4,6) =-0.0107d0
      ro(6,6) =-0.0318d0
      rr(2,6) = 0.893d0
      rr(4,6) = 2.163d0
      rr(6,6) = 11.75d0                  
c
      isn(7) = 15
      isv(7) =  5
      g(7)   = 4.d0/3.d0
      stev(2,7) =-2.d0/(9.d0*35.d0)
      stev(4,7) =-8.d0/(11.d0*45.d0*273.d0)
      stev(6,7) = 4.d0/(13.d0*13.d0*11.d0*11.d0*27.d0*7.d0)
      ele(7)   ='Dy(III)'
      ro(2,7) = 0.527d0
      ro(4,7) =-0.0199d0
      ro(6,7) =-0.0316d0
      rr(2,7) = 0.849d0
      rr(4,7) = 1.977d0
      rr(6,7) = 10.44d0
c
      isn(8) = 16
c      isv(8) = 7 
      isv(8) = 0 
      g(8)   = 5.d0/4.d0
      stev(2,8) =-1.d0/(15.d0*30.d0)
      stev(4,8) =-1.d0/(11.d0*2730.d0)
      stev(6,8) =-5.d0/(13.d0*33.d0*9009.d0)
      ele(8)   ='Ho(III)'
      ro(2,8) = 0.534d0
      ro(4,8) =-0.0306d0
      ro(6,8) =-0.0313d0
      rr(2,8) = 0.810d0
      rr(4,8) = 1.816d0
      rr(6,8) = 9.345d0
c
      isn(9) = 15
      isv(9) = 7 
      g(9)   = 6.d0/5.d0
      stev(2,9) = 4.d0/(45.d0*35.d0)
      stev(4,9) = 2.d0/(11.d0*15.d0*273.d0)
      stev(6,9) = 8.d0/(13.d0*13.d0*11.d0*11.d0*27.d0*7.d0)
      ele(9)   ='Er(III)'
      ro(2,9) = 0.544d0
      ro(4,9) =-0.0427d0
      ro(6,9) =-0.0310d0
      rr(2,9) = 0.773d0
      rr(4,9) = 1.677d0
      rr(6,9) = 8.431d0
c
      isn(10) = 12
      isv(10) = 1 
      g(10)   = 7.d0/6.d0
      stev(2,10) = 1.d0/(99.d0)
      stev(4,10) = 8.d0/(3.d0*11.d0*1485.d0)
      stev(6,10) =-5.d0/(13.d0*33.d0*2079.d0)
      ele(10)   ='Tm(III)'
      ro(2,10) = 0.554d0
      ro(4,10) =-0.0567d0
      ro(6,10) =-0.0306d0
      rr(2,10) = 0.740d0
      rr(4,10) = 1.555d0
      rr(6,10) = 7.659d0
c
      if (inew.eq.0) then
        isn(11) = 7
        isv(11) = 5
        g(11)  = 8.d0/7.d0
      else
        isn(11) = ielepin
        isv(11) = inucpin
        g(11) = gz
      endif
      stev(2,11) = 2.d0/(63.d0)
      stev(4,11) =-2.d0/(77.d0*15.d0)
      stev(6,11) = 4.d0/(13.d0*33.d0*63.d0)
      ele(11)   ='Yb(III)'
      ro(2,11) = 0.571d0
      ro(4,11) =-0.0725d0
      ro(6,11) =-0.0300d0
      rr(2,11) = 0.571d0
      rr(4,11) = 1.448d0
      rr(6,11) = 7.003d0
c
      isn(12) = 7
      isv(12) = 1
      g(12)   = 8.d0/7.d0
      stev(2,12) = 2.d0/(63.d0)
      stev(4,12) =-2.d0/(77.d0*15.d0)
      stev(6,12) = 4.d0/(13.d0*33.d0*63.d0)
      ele(12)   ='Yb(III)'
      ro(2,12) = 0.571d0
      ro(4,12) =-0.0725d0
      ro(6,12) =-0.0300d0
      rr(2,12) = 0.571d0
      rr(4,12) = 1.448d0
      rr(6,12) = 7.003d0
c
      return
      end
c
      subroutine war
c 
      implicit double precision (a-h,o-z)
c 
      include 'simpre.par'
c     
      dimension plm(6,0:6)
      dimension g(13)
      dimension stev(6,13)
      dimension ro(6,13),rr(6,13)
      dimension z(ichar),z0(ichar)
      dimension xyz(3,ichar),xyz0(3,ichar)
      dimension rtp(3,ichar),rtp0(3,ichar)
      dimension isn(13)
      dimension isv(13)
c 
      character*4 uni(3)
      character*7 ele(13)
c 
      common /a592/ plm
      common /a500/ g
      common /a501/ stev
      common /a503/ ro,rr
      common /a603/ z,z0
      common /a600/ xyz,xyz0
      common /a602/ rtp,rtp0
      common /a504/ pi
      common /rr21/ temph
      common /rr60/  paso_out
      common /rr50/ temp1,temp2,field
      common /i550/ isteptemp
      common /i500/ isn
      common /i502/ isv
      common /i501/ inn
      common /ii22/ icammaxh,icamstph,iangh
      common /ixxx/ nc  
      common /aa10/ uni    
      common /c002/ ele
c 
      open (4,file='simpre.dat',status='unknown')
c
      uni(1) = ' K  '
      uni(2) = 'meV '
      uni(3) = 'cm-1'
c
      inn = 0
      do 111 k=1,ichar
        z0(k) = 0.d0
      do 111 iu=1,3
        rtp0(iu,k) = 0.d0
        xyz0(iu,k) = 0.d0
        rtp(iu,k) = 0.d0
        xyz(iu,k) = 0.d0
 111   continue
c 
      read (4,*)
      read (4,*)
      read (4,900) inn
 900   format (i3)
      if (inn.lt.1.or.inn.gt.13) then
        write (3,*)  
        write (3,*) '*** INPUT ERROR ***'
        write (3,*) 'Bad definition of lanthanoid/"user" ion code, the i
     &on code must be a number between 1 and 12' 
        write (3,*) 'Execution stops...'
        write (3,*)   
        stop
      endif
c 
        read (4,900) nc
        if (nc.lt.0) then
          write (3,*)  
          write (3,*) '*** INPUT ERROR ***'
          write (3,*) 'Bad definition of coordination number, coordinati
     &on number must be positive'
          write (3,*) 'Execution stops...'
          write (3,*)  
          stop
        endif
        if (nc.gt.ichar) then
          write (3,*)  
          write (3,*) '*** INPUT ERROR ***'
          write (3,*) 'Bad definition of coordination number, coordinati
     &on number must be lower or equal to ichar'
          write (3,*) 'Execution stops...'
          write (3,*)  
          stop
        endif
        ncmax=0
        if (nc.gt.ncmax) ncmax=nc
c
      if (icoo.eq.1) then
        do 14 n=1,nc 
          read (4,902) jj,(rtp0(k,jj),k=1,3),z0(jj)
c
          if (jj.ne.n) then
           write (3,*)  
           write (3,*) '*** INPUT WARNING ***'
           write (3,*) 'Warning coor',n
           write (3,*) 'Execution continues...'
           write (3,*) 
          endif
          if (z0(jj).lt.0.d0) then
           write (3,*)  
           write (3,*) '*** INPUT ERROR ***'
           write (3,897) 'Bad definition of charge',jj,':', z0(jj), '  
     &must be positive'
           write (3,*) 'Execution stops...'
           write (3,*)  
           stop
          endif
          if (rtp0(2,jj).lt.0.or.rtp0(2,jj).gt.180.d0) then
           write (3,*)  
           write (3,*) '*** INPUT WARNING ***'
           write (3,898) 'Bad definition of theta in',jj, ': 0 <= theta 
     &<= 180'
           write (3,*) 'Execution continues...'
           write (3,*) 
          endif
          if (rtp0(3,jj).lt.0.or.rtp0(3,jj).gt.360.d0) then
           write (3,*)  
           write (3,*) '*** INPUT WARNING ***'
           write (3,899) 'Bad definition of phi in',jj, ': 0 <= phi <= 3
     &60'
           write (3,*) 'Execution continues...'
           write (3,*) 
      endif
c
 897  format(a24,i3,a1,f8.3,a19)
 898  format(a26,i3,a19)
 899  format(a24,i3,a17) 
c         
          rtp0(2,jj)=rtp0(2,jj)*2.d0*pi/360.d0
          rtp0(3,jj)=rtp0(3,jj)*2.d0*pi/360.d0
c
          xyz0(1,jj)=rtp0(1,jj)*dsin(rtp0(2,jj))*dcos(rtp0(3,jj))   
          xyz0(2,jj)=rtp0(1,jj)*dsin(rtp0(2,jj))*dsin(rtp0(3,jj))  
          xyz0(3,jj)=rtp0(1,jj)*dcos(rtp0(2,jj))
 14      continue
      endif
c
      if (icoo.eq.2) then
        do 15 n=1,nc
          read (4,902) jj,(xyz0(k,jj),k=1,3),z0(jj)
          if (jj.ne.n) then
          write (3,*)  
          write (3,*) '*** INPUT WARNING ***'
          write (3,*) 'Warning coor',n
          write (3,*) 'Execution continues...'
          write (3,*)
          stop
          endif
          if (z0(jj).lt.0.d0) then
           write (3,*)  
           write (3,*) '*** INPUT ERROR ***'
           write (3,897) 'Bad definition of charge',jj,':', z0(jj), '  
     &must be positive'
           write (3,*) 'Execution stops...'
           write (3,*)  
           stop
          endif
c
          rtp0(1,jj)=dsqrt(xyz0(1,jj)**2.d0+xyz0(2,jj)**2.d0 
     &                      +xyz0(3,jj)**2.d0)               
          rtp0(2,jj)=dacos(xyz0(3,jj)/rtp0(1,jj))  
          rtp0(3,jj)=atan2(xyz0(2,jj),xyz0(1,jj))  
 15      continue
      endif
c
        if(isus.eq.1) then
        read (4,903) temp1,temp2,isteptemp,field
        else
        read (4,*) 
        temp1=2.d0
        temp2=10.d0
        isteptemp=2
        field=100.d0
        endif
c
        if (temp1.lt.0.d0) then
        write (3,*)  
        write (3,*) '*** INPUT ERROR ***'
        write (3,*) 'Bad definition of initial temperature, Tmin(K) must
     & be positive'
        write (3,*) 'Execution stops...'
        write (3,*)  
        stop
        endif
        if (temp2.lt.0.d0) then
        write (3,*)  
        write (3,*) '*** INPUT ERROR ***'
        write (3,*) 'Bad definition of final temperature, Tmax(K) must b
     &e positive'
        write (3,*) 'Execution stops...'
        write (3,*)  
        stop
        endif
        if (temp2.lt.temp1) then
        write (3,*)  
        write (3,*) '*** INPUT ERROR ***'
        write (3,*) 'Tmax(K) must be higher than Tmin(K)'
        write (3,*) 'Execution stops...'
        write (3,*)  
        stop
        endif
        if (isteptemp.lt.2) then
        write (3,*)  
        write (3,*) '*** INPUT ERROR ***'
        write (3,*) 'Bad definition of number of points, # of points mus
     &t be equal or larger than 2'
        write (3,*) 'Execution stops...'
        write (3,*)  
        stop
        endif
c       
 903   format (2f9.3,i6,f9.2)
        if(imag.eq.1) then
        read (4,904) temph,icammaxh,icamstph,iangh
        else
        read(4,*)
        temph=2.d0
        icammaxh=5000
        icamstph=25
        iangh=61
        endif     
c
        if (temph.lt.0.d0) then
        write (3,*)  
        write (3,*) '*** INPUT ERROR ***'
        write (3,*) 'Bad definition of T(K), T(K) must be positive'
        write (3,*) 'Execution stops...'
        write (3,*) 
        stop
        endif
 904   format (f9.3,i9,i6,i9)
c
       if (inn.eq.13) then
        read (4,*)
        read (4,906) esp1,esp2,ele(13),esp3,esp4,esp5,isn(13),g(13)
        if(isn(13).lt.1.or.isn(13).gt.16) then
        write (3,*)  
        write (3,*) '*** INPUT ERROR ***'
        write (3,*) 'Bad definition of 2*J of the "user" ion, 2*J must b
     &e an integer between 1 and 16'
        write (3,*) 'Execution stops...'
        write (3,*) 
        stop
        endif
        read (4,907) stev(2,13),stev(4,13),stev(6,13) 
        read (4,908) ro(2,13),ro(4,13),ro(6,13)
        read (4,908) rr(2,13),rr(4,13),rr(6,13)      
       endif
      close (4)
c     
      write (3,234) ele(inn)  
      write (3,237) nc
      write (3,235) g(inn)
      write (3,207) uni(iuni)
      write (3,*)
c    
      write (3,*) 'stv           2           4           6'
      write (3,923) (stev(i,inn),i=2,6,2)
      write (3,*) 
c
      write (3,*) '<r>k          2           4           6'
      write (3,923) (rr(i,inn),i=2,6,2)
      write (3,*) 
c      
      if (ishi.eq.1) then
      write (3,*) 'shi           2           4           6'
      write (3,923) (ro(i,inn),i=2,6,2)
      write (3,*)
      else
      continue 
      endif
      write (3,*)
      write (3,*) ' input coordinates'
      write (3,*)
      write (3,*) ' cartesian (A)'
      write (3,*) '        x            y            z            Z  '
c
      do 143 im=1,ncmax
      write (3,910) (xyz0(k,im),k=1,3),z0(im)
 143   continue
      write (3,*) 
      write (3,*) ' spherical (rad)'
      write (3,*) '        r          theta         phi           Z  '
      do 144 im=1,ncmax
      write (3,910) (rtp0(k,im),k=1,3),z0(im)
 144   continue
 923   format ('    ',7f12.8)
 902   format (i3,4f13.7)
 910   format (4f13.7)
 911   format ('        r ',6f10.3)
 912   format ('    theta ',6f10.3)
 913   format ('      phi ',6f10.3)
c
      do 160 n=1,nc 
        z(n)=z0(n)
        do 160 iu=1,3
          xyz(iu,n)=xyz0(iu,n)
          rtp(iu,n)=rtp0(iu,n)
 160   continue
c
      if (iuni.eq.1) paso_out = 1.4387770d0
      if (iuni.eq.2) paso_out = 0.1239841930d0
      if (iuni.eq.3) paso_out = 1.d0
c
 234   format ('               ion:   ',a10)
 235   format ('                 g:   ',f10.3)
 237   format (' number of charges:   ',i10)
 207   format ('             units:   ',a10) 
 906   format (a5,a5,a7,a5,a5,a5,i2,f17.11)
 907   format (3f17.11)
 908   format (3f17.4)
       return
       end
c
      subroutine fun
c
      implicit double precision (a-h,o-z)
c
      include 'simpre.par'
c
      dimension rmsa(idtot)
      dimension rmsv(idtot)
      dimension isn(13)
      dimension isv(13)
c
      common /rr140/ rmsa
      common /rr141/ rmsv
      common /i500/ isn
      common /i502/ isv
      common /i501/ inn
      common /ii50/ ix
      ix = 0
      do 5 ist=-isn(inn),isn(inn),2
      do 5 is1=-isv(inn),isv(inn),2
        ix=ix+1
        rmsa(ix)= dble(ist)/2.d0
        rmsv(ix)= dble(is1)/2.d0
 5    continue
c
      return
      end
c
      subroutine operators
c
      implicit double precision (a-h,o-z)
c
      include 'simpre.par'
c
      dimension a1(idtot),a2(idtot),a3(idtot),a4(idtot),
     &          a5(idtot),a6(idtot)
      dimension sme1(idtot),sma1(idtot),sma2(idtot)
      dimension sma3(idtot),sma4(idtot),sma5(idtot),sma6(idtot)
      dimension rmsa(idtot)
      dimension rmse(idtot)
      dimension rmsv(idtot)
      dimension isn(13)
      dimension isv(13)
c
      common /op01/ sd,a1,a2,a3,a4,a5,a6,sme1
      common /op02/ s1,s2,s3
      common /op03/ sma1,sma2,sma3,sma4,sma5,sma6
      common /rr140/ rmsa
      common /rr141/ rmsv
      common /i500/ isn
      common /i502/ isv
      common /i501/ inn
c
      write (3,*)
      i = 0
      sd = isn(inn)/2.d0
      s1 = sd*(sd+1.d0)
      s2 = s1**2
      s3 = s1**3
      do 1 ist=-isn(inn),isn(inn),2
        i=i+1
        rmse(i)= dble(ist)/2.d0
        a1(i) = rmse(i)
        a2(i) = a1(i)**2
        a3(i) = a1(i)**3
        a4(i) = a1(i)**4
        a5(i) = a1(i)**5
        a6(i) = a1(i)**6
        if ((a1(i)+1).lt.(sd+0.1d0)) then
          sma1(i) = dsqrt((sd-a1(i))*(sd+a1(i)+1))
        else
          sma1(i) = 0.d0
        endif
        if (a1(i)+2.lt.sd+0.1d0) then
          sma2(i)=sma1(i)*
     &             dsqrt((sd-a1(i)-1)*(sd+a1(i)+2))
        else
          sma2(i) = 0.d0
        endif
        if (a1(i)+3.lt.sd+0.1d0) then
          sma3(i)=sma2(i)*
     &             dsqrt((sd-a1(i)-2)*(sd+a1(i)+3))
        else
          sma3(i) = 0.d0
        endif
        if (a1(i)+4.lt.sd+0.1d0) then
          sma4(i)=sma3(i)*
     &             dsqrt((sd-a1(i)-3)*(sd+a1(i)+4))
        else
          sma4(i) = 0.d0
        endif
        if (a1(i)+5.lt.sd+0.1d0) then
          sma5(i)=sma4(i)*
     &             dsqrt((sd-a1(i)-4)*(sd+a1(i)+5))
        else
          sma5(i) = 0.d0
        endif
        if (a1(i)+6.lt.sd+0.1d0) then
          sma6(i)=sma5(i)*
     &             dsqrt((sd-a1(i)-5)*(sd+a1(i)+6))
        else
          sma6(i) = 0.d0
        endif
c
        if (a1(i)-1.gt.-sd-0.1d0) then
          sme1(i) = dsqrt((sd+a1(i))*(sd-a1(i)+1))
        else
          sme1(i) = 0.d0
        endif
c
 1    continue
c
      i = 0
      do 2 ist=-isn(inn),isn(inn),2
        i=i+1
c
 2    continue
c
      i = 0
      do 3 ist=-isn(inn),isn(inn),2
        i=i+1
c
 3    continue
c
 901  format (17f11.2)
c
      return
      end
c
      subroutine rota
c
      implicit double precision (a-h,o-z)
  
      include 'simpre.par'
c
      complex*16 zz(idtot,idtot)
c
      dimension amemalpha(10)
      dimension z(ichar),z0(ichar)
      dimension xyz(3,ichar),xyz0(3,ichar)
      dimension rtp(3,ichar),rtp0(3,ichar)
      dimension rotab(0:1800)             
      dimension rotaa(0:3600)   
      dimension rotag(0:3600)               
      dimension aaa(3,ichar)
      dimension amemaaa(3,ichar)
      dimension amemrtp(3,ichar)
      dimension amemz(ichar) 
      dimension imema(10),imemb(10),imemg(10)
c  
      common /rr132/ dd 
      common /rr133/ zz
      common /a603/ z,z0
      common /a600/ xyz,xyz0
      common /a602/ rtp,rtp0
      common /a504/ pi
      common /ii50/ ix
      common /ixxx/ nc
c
      amemalpha1=0.d0
c                                      
      do 1 iii=1,10
      amemalpha(iii)=0.d0
      imemb(iii)=0.d0
      imema(iii)=0.d0
      imemg(iii)=0.d0
 1    continue                   
c
      do 20 ib=0,180,3  
         rotab(ib) = 2.d0*pi*dble(ib)/360.d0
 
      do 220 ia=0,360,3          
         rotaa(ia) = 2.d0*pi*dble(ia)/360.d0 
          
      do 221 ig=0,360,3    
         rotag(ig) = 2.d0*pi*dble(ig)/360.d0                            
c
      do 401 iN=1,nc                                                    
c                                                                        
         aaa(1,iN)=xyz0(1,iN)*(dcos(rotaa(ia))*dcos(rotab(ib))
     &                 *dcos(rotag(ig))-dsin(rotaa(ia))*dsin(rotag(ig)))
     &                 +xyz0(2,iN)*(-dcos(rotaa(ia))*dcos(rotab(ib))
     &                 *dsin(rotag(ig))-dsin(rotaa(ia))*dcos(rotag(ig)))
     &                 +xyz0(3,iN)*(dcos(rotaa(ia))*dsin(rotab(ib)))
c   
         aaa(2,iN)=xyz0(1,iN)*(dsin(rotaa(ia))*dcos(rotab(ib))  
     &                 *dcos(rotag(ig))+dcos(rotaa(ia))*dsin(rotag(ig)))
     &                 +xyz0(2,iN)*(-dsin(rotaa(ia))*dcos(rotab(ib)) 
     &                 *dsin(rotag(ig))+dcos(rotaa(ia))*dcos(rotag(ig)))
     &                 +xyz0(3,iN)*(dsin(rotaa(ia))*dsin(rotab(ib))) 
c       
         aaa(3,iN)=xyz0(1,iN)*(-dsin(rotab(ib))*dcos(rotag(ig))) 
     &                 +xyz0(2,iN)*(dsin(rotab(ib))*dsin(rotag(ig)))
     &                 +xyz0(3,iN)*dcos(rotab(ib))      
c    
         rtp(1,iN)=dsqrt(aaa(1,iN)**2.d0+aaa(2,iN)**2.d0                
     &                   +aaa(3,iN)**2.d0)               
         rtp(2,iN)=dacos(aaa(3,iN)/rtp(1,iN))                           
         rtp(3,iN)=atan2(aaa(2,iN),aaa(1,iN))                           
c                           
 401  continue                                                        
c                                                   
      call bkq
      call ene
c
      amaxalpha=0.d0      
      do 88 ie=1,ix
         alpha=abs(zz(ie,1))**2.d0
         if(alpha.ge.amaxalpha) then
          amaxalpha=alpha
          else
           continue
          endif
  88  continue
c
       if(amaxalpha.lt.amemalpha(10)) goto 221
       do 66 ico=1,9
       if(amaxalpha.gt.amemalpha(ico)) then
       do 77 iii=ico,9
       amemalpha(iii+1)=amemalpha(iii)
       imemb(iii+1)=ib                                     
       imema(iii+1)=ia 
       imemg(iii+1)=ig  
  77   continue      
       amemalpha(ico)=amaxalpha
       imemb(ico)=ib                                     
       imema(ico)=ia 
       imemg(ico)=ig  
       endif
 66    continue
c
       if(amaxalpha.gt.amemalpha(10)) then   
       amemalpha(10)=amaxalpha
       imemb(10)=ib                                     
       imema(10)=ia 
       imemg(10)=ig  
       endif
c       
  221    continue
  220    continue 
  20     continue
c
      do 3 ii=1,10
c
      do 30 ib=(imemb(ii)*10)-20,(imemb(ii)*10)+20
         rotab(ib) = 2.d0*pi*dble(ib)/3600.d0
c 
      do 320 ia=(imema(ii)*10)-20,(imema(ii)*10)+20         
         rotaa(ia) = 2.d0*pi*dble(ia)/3600.d0 
c          
      do 321 ig=(imemg(ii)*10)-20,(imemg(ii)*10)+20 
         rotag(ig) = 2.d0*pi*dble(ig)/3600.d0        
c
      do 301 iN=1,nc 
c                                                                        
         aaa(1,iN)=xyz0(1,iN)*(dcos(rotaa(ia))*dcos(rotab(ib))
     &                 *dcos(rotag(ig))-dsin(rotaa(ia))*dsin(rotag(ig)))
     &                 +xyz0(2,iN)*(-dcos(rotaa(ia))*dcos(rotab(ib))
     &                 *dsin(rotag(ig))-dsin(rotaa(ia))*dcos(rotag(ig)))
     &                 +xyz0(3,iN)*(dcos(rotaa(ia))*dsin(rotab(ib)))
c   
         aaa(2,iN)=xyz0(1,iN)*(dsin(rotaa(ia))*dcos(rotab(ib))  
     &                 *dcos(rotag(ig))+dcos(rotaa(ia))*dsin(rotag(ig)))
     &                 +xyz0(2,iN)*(-dsin(rotaa(ia))*dcos(rotab(ib)) 
     &                 *dsin(rotag(ig))+dcos(rotaa(ia))*dcos(rotag(ig)))
     &                 +xyz0(3,iN)*(dsin(rotaa(ia))*dsin(rotab(ib))) 
c       
         aaa(3,iN)=xyz0(1,iN)*(-dsin(rotab(ib))*dcos(rotag(ig))) 
     &                 +xyz0(2,iN)*(dsin(rotab(ib))*dsin(rotag(ig)))
     &                 +xyz0(3,iN)*dcos(rotab(ib))      
c    
         rtp(1,iN)=dsqrt(aaa(1,iN)**2.d0+aaa(2,iN)**2.d0                
     &                   +aaa(3,iN)**2.d0)               
         rtp(2,iN)=dacos(aaa(3,iN)/rtp(1,iN))                           
         rtp(3,iN)=atan2(aaa(2,iN),aaa(1,iN))                           
c                           
 301  continue
c
      call bkq
      call ene                                       
c
      amaxalpha=0.d0      
      do 55 ie=1,ix
         alpha=abs(zz(ie,1))**2.d0
         if(alpha.ge.amaxalpha) then
          amaxalpha=alpha
          else
           continue
          endif
  55  continue
c
       if(amaxalpha.gt.amemalpha1) then    
       amemalpha1=amaxalpha
       imemb1=ib                                     
       imema1=ia 
       imemg1=ig  
       endif
c
  321    continue
  320    continue 
  30     continue
  3      continue
c
      do 467 iN=1,nc  
c
       amemaaa(1,iN)=xyz0(1,iN)*(dcos(rotaa(imema1))
     &               *dcos(rotab(imemb1))*dcos(rotag(imemg1))
     &               -dsin(rotaa(imema1))*dsin(rotag(imemg1)))
     &               +xyz0(2,iN)*(-dcos(rotaa(imema1))
     &               *dcos(rotab(imemb1))*dsin(rotag(imemg1))
     &               -dsin(rotaa(imema1))*dcos(rotag(imemg1))) 
     &               +xyz0(3,iN)*(dcos(rotaa(imema1))
     &               *dsin(rotab(imemb1)))
c
       amemaaa(2,iN)=xyz0(1,iN)*(dsin(rotaa(imema1))
     &               *dcos(rotab(imemb1))*dcos(rotag(imemg1))
     &               +dcos(rotaa(imema1))*dsin(rotag(imemg1))) 
     &               +xyz0(2,iN)*(-dsin(rotaa(imema1))
     &               *dcos(rotab(imemb1))*dsin(rotag(imemg1))
     &               +dcos(rotaa(imema1))*dcos(rotag(imemg1))) 
     &               +xyz0(3,iN)*(dsin(rotaa(imema1))
     &               *dsin(rotab(imemb1))) 
c       
       amemaaa(3,iN)=xyz0(1,iN)*(-dsin(rotab(imemb1)) 
     &               *dcos(rotag(imemg1)))+xyz0(2,iN)
     &               *(dsin(rotab(imemb1))*dsin(rotag(imemg1)))
     &               +xyz0(3,iN)*dcos(rotab(imemb1))      
c
       rtp(1,iN)= dsqrt(amemaaa(1,iN)**2.d0+amemaaa(2,iN)**2.d0       
     &                 +amemaaa(3,iN)**2.d0)               
       rtp(2,iN)= dacos(amemaaa(3,iN)/(dsqrt(amemaaa(1,iN)**2.d0      
     &                 +amemaaa(2,iN)**2.d0+amemaaa(3,iN)**2.d0)))    
       rtp(3,iN)= atan2(amemaaa(2,iN),amemaaa(1,iN))                  
c
  467  continue      
c     
       write (3,*) 
       write (3,*) '                  ROTATION                     '
       write (3,*) '_______________________________________________'
       write (3,*)
       write (3,915) imema1/10.d0 
       write (3,916) imemb1/10.d0 
       write (3,917) imemg1/10.d0       
       write (3,*)
       write (3,*) '***********************************************'
       write (3,*) '         COORDINATES AFTER ROTATION            '
       write (3,*) '***********************************************'    
       write (3,*) '                                               '    
       write (3,*) '             Spherical coordinates             '
       write (3,*) '_______________________________________________'
       write (3,*) 
       write (3,*) '  #        r       theta      phi        charge'
       write (3,*) '  #       [A]      [rad]     [rad]        [e]  '
       write (3,*) 
       do 2 inum=1,nc                                                
       write (3,906) inum,rtp(1,inum),rtp(2,inum),rtp(3,inum),z(inum)  
       write (5,906) inum,rtp(1,inum),rtp(2,inum),rtp(3,inum),z(inum)  
 2    continue                                        
c
 915  format(' alpha =',f7.1,' degrees')
 916  format(' beta =',f7.1,' degrees')
 917  format(' gamma =',f7.1,' degrees')
 906  format (i4,'  ',3f10.5,'  ',f10.5)
c
      return
      end
c
      subroutine bkq
c
      implicit double precision (a-h,o-z)
c
      include 'simpre.par'
c
      complex*16 c6,c7
      complex*16 ylm
c
      dimension plm(6,0:6)
      dimension amp(6,0:6),bmp(6,0:6)
      dimension ramp(6,0:6),rbmp(6,0:6)
      dimension ro(6,13),rr(6,13)
      dimension stev(6,13)
      dimension z(ichar),z0(ichar)
      dimension xyz(3,ichar),xyz0(3,ichar)
      dimension rtp(3,ichar),rtp0(3,ichar)
c
      common /a501/ stev
      common /a601/ ramp,rbmp
      common /a603/ z,z0
      common /a600/ xyz,xyz0
      common /a602/ rtp,rtp0
      common /a503/ ro,rr
      common /a504/ pi
      common /a592/ plm
      common /i501/ inn
      common /ixxx/ nc
c
      external ylm
c
      f11 = 219474.6d0
      f22 = 1.889725989d0
c
      do 1 l=2,6,2
      do 1 m=0,l
      amp(l,m) = 0.d0
      bmp(l,m) = 0.d0
c
      c1 = 4*pi/(2*l+1) 
c
      do 2 n=1,nc 
c
      dis   = rtp(1,n)
      theta = rtp(2,n)
      phi   = rtp(3,n)
      car   = z(n)
c
      c2 = car*f11/((dis*f22)**(l+1))
      c3 = rr(l,inn)
      if(ishi.eq.0) then
      c4= 1.d0
      else
      c4 = (1-ro(l,inn))
      endif
      c5 = ((-1.d0)**m)*plm(l,m)
c
      c6 = ylm(l,m,theta,phi)
      c7 = ((-1.d0)**m)*conjg(c6)
      if(m.gt.0) then 
      c8 =  Real(dsqrt(0.5d0)*(c7+((-1.d0)**m)*c6))
      c9 = -Aimag(dsqrt(0.5d0)*(c7-((-1.d0)**m)*c6))
      endif
c
      if (m.eq.0) then
        amp(l,m) = amp(l,m) + Real(c1*c2*c5*c6)  
        bmp(l,m) = bmp(l,m) + 0.d0
      else
        amp(l,m) = amp(l,m) + c1*c2*c5*c8 
        bmp(l,m) = bmp(l,m) + c1*c2*c5*c9 
      endif
c
 2    continue
c
 987  format (8f12.4)
 988  format (i4,8f12.4)
c
      ramp(l,m) = amp(l,m)*c3*c4 
      rbmp(l,m) = bmp(l,m)*c3*c4 
c
 1    continue
c
      return
      end
c
      subroutine zee
c
      implicit double precision (a-h,o-z)
c
      include 'simpre.par'
c
      dimension g(13)
      dimension rmsa(idtot)
      dimension rmsv(idtot)
      dimension zeex(idtot*(idtot+1)/2),zeey(idtot*(idtot+1)/2)
      dimension zeez(idtot*(idtot+1)/2)
      dimension a1(idtot),a2(idtot),a3(idtot),a4(idtot),
     &          a5(idtot),a6(idtot)
      dimension sme1(idtot),sma1(idtot),sma2(idtot)
      dimension sma3(idtot),sma4(idtot),sma5(idtot),sma6(idtot)
      dimension isn(13)
      dimension isv(13)
c
      common /a500/ g
      common /op01/ sd,a1,a2,a3,a4,a5,a6,sme1
      common /op02/ s1,s2,s3
      common /op03/ sma1,sma2,sma3,sma4,sma5,sma6
      common /rr140/ rmsa
      common /rr141/ rmsv
      common /rr150/ zeex,zeey,zeez
      common /i500/ isn
      common /i505/ isv
      common /i501/ inn
      common /ii50/ ix
c
      do 1 i=1,idtot*(idtot+1)/2
        zeex(i) = 0.d0
        zeey(i) = 0.d0
        zeez(i) = 0.d0
 1    continue
c
      ixx=ix
      ix=isn(inn)+1
      iy=isv(inn)+1
      ii=0
      do 4 i=1,ix
      do 4 ia=1,iy
      do 4 j=1,i
      do 4 ja=1,iy
       if ((ja.gt.ia).and.(i.eq.j)) goto 4
       ii=ii+1
      if ((j.eq.i).and.(ia.eq.ja)) then
       zeez(ii)=a1(i)*g(inn)
      endif
      if ((j.eq.(i-1)).and.(ia.eq.ja)) then
       zeex(ii) = sma1(j)*g(inn)/2.d0
       zeey(ii) =-sma1(j)*g(inn)/2.d0
      endif
 4    continue
      ix=ixx
c
 400  format (2i5,3f12.6)
 401  format (20f12.6)
      return
      end
c
      subroutine ene
c
      implicit double precision (a-h,o-z)
c
      include 'simpre.par'
c
      complex*16 zz(idtot,idtot)
      complex*16 bb(idtot*(idtot+1)/2)
      complex*16 a(idtot*(idtot+1)/2)
      complex*16 work(2*idtot)
      complex*16 x3
      complex*16 hyper(idtot*(idtot+1)/2),hypar(idtot*(idtot+1)/2)
      complex*16 quad(idtot*(idtot+1)/2)
c
      dimension plm(6,0:6)
      dimension g(13)
      dimension stev(6,13)
      dimension ro(6,13),rr(6,13)
      dimension dd(idtot) 
      dimension rwork(3*idtot)
      dimension rmsa(idtot)
      dimension rmsv(idtot)
      dimension ramp(6,0:6),rbmp(6,0:6)
      dimension isn(13)
      dimension isv(13)
c
      integer   info,ldz,n
c
      character*7 ele(13)
      character*4 uni(3)
      character jobz,uplo
c
      common /a500/ g
      common /a501/ stev
      common /a503/ ro,rr
      common /a504/ pi
      common /a592/ plm
      common /a601/ ramp,rbmp
      common /aa99/ quad
      common /rr110/ a
      common /rr120/ bb
      common /rr132/ dd
      common /rr133/ zz
      common /rr134/ ecero
      common /rr140/ rmsa
      common /rr141/ rmsv
      common /rr21/ temph
      common /rr50/ temp1,temp2,field
      common /i550/ isteptemp
      common /i500/ isn
      common /i502/ isv
      common /i501/ inn
      common /ii50/ ix
      common /aa10/ uni
      common /c002/ ele
      common /RR16/ hyper,hypar
      common /RS99/ fclock
c
      uni(1) = ' K  '
      uni(2) = 'meV '
      uni(3) = 'cm-1'
c
      sn = isn(inn)/2.d0
c
      call HYPA(i,j,ii)
      call HYPE(i,j,ii)
      call QUADA(i,j,ii)
      ii=0
      ixx=ix
      ix=isn(inn)+1
      do 6 i=1,ix 
      do 6 ia=((i-1)*(isv(inn)+1))+1, (i*(isv(inn)+1)), 1 
      do 6 j=1,ix
      do 6 ja=((j-1)*(isv(inn)+1))+1, (j*(isv(inn)+1)), 1 
         if (ja.gt.ia) goto 6 
         ii=ii+1 
        a(ii) = (0.d0,0.d0)
        bb(ii) = (0.d0,0.d0)
c 
        if (rmsv(ia).ne.rmsv(ja)) goto 77 
       do 7 l=2,6,2
       do 7 m=0,l
             if((iparead.eq.1).and.(ii.eq.1)) then
               open (7,file='simpre.bkq',status='unknown') 
               read (7,333) ramp(l,m) , rbmp(l,m)
             endif
 333  format (2f13.8)
          if ((i-m).ne.j) goto 7 
          if (iparead.eq.0) then
             x1 = ramp(l,m)*stev(l,inn)*oplm(i,j,l,m,sn)
             x2 =-rbmp(l,m)*stev(l,inn)*oplm(i,j,l,m,sn)
             x3 = dcmplx(x1,x2)
             a(ii) = a(ii) + x3  
          else
              if (istevens.eq.1) then ! Bkq STEVENS
                 x1 = ramp(l,m)*oplm(i,j,l,m,sn)
                 x2 =-rbmp(l,m)*oplm(i,j,l,m,sn)
                 x3 = dcmplx(x1,x2)
                 a(ii) = a(ii) + x3  
              elseif (istevens.eq.0) then ! Bkq WYBOURNE
                 if ((l.eq.2).and.(m.eq.0)) then
                   aa=2.d0
                   x1 = ramp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x2 =-rbmp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x3 = dcmplx(x1,x2)
                   a(ii) = a(ii) + x3  
                 elseif ((l.eq.2).and.(m.eq.1)) then
                   aa=1.d0/dsqrt(6.0d0)
                   x1 = ramp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x2 =-rbmp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x3 = dcmplx(x1,x2)
                   a(ii) = a(ii) + x3  
                 elseif ((l.eq.2).and.(m.eq.2)) then
                   aa=2.d0/dsqrt(6.0d0)
                   x1 = ramp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x2 =-rbmp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x3 = dcmplx(x1,x2)
                   a(ii) = a(ii) + x3  
                 elseif ((l.eq.4).and.(m.eq.0)) then
                   aa=8.d0
                   x1 = ramp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x2 =-rbmp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x3 = dcmplx(x1,x2)
                   a(ii) = a(ii) + x3  
                 elseif ((l.eq.4).and.(m.eq.1)) then
                   aa=2.d0/dsqrt(5.0d0)
                   x1 = ramp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x2 =-rbmp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x3 = dcmplx(x1,x2)
                   a(ii) = a(ii) + x3  
                 elseif ((l.eq.4).and.(m.eq.2)) then
                   aa=4.d0/dsqrt(10.0d0)
                   x1 = ramp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x2 =-rbmp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x3 = dcmplx(x1,x2)
                   a(ii) = a(ii) + x3  
                 elseif ((l.eq.4).and.(m.eq.3)) then
                   aa=2.d0/dsqrt(35.0d0)
                   x1 = ramp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x2 =-rbmp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x3 = dcmplx(x1,x2)
                   a(ii) = a(ii) + x3  
                 elseif ((l.eq.4).and.(m.eq.4)) then
                   aa=8.d0/dsqrt(70.0d0)
                   x1 = ramp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x2 =-rbmp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x3 = dcmplx(x1,x2)
                   a(ii) = a(ii) + x3  
                 elseif ((l.eq.6).and.(m.eq.0)) then
                   aa=16.d0
                   x1 = ramp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x2 =-rbmp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x3 = dcmplx(x1,x2)
                   a(ii) = a(ii) + x3  
                 elseif ((l.eq.6).and.(m.eq.1)) then
                   aa=8.d0/dsqrt(42.0d0)
                   x1 = ramp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x2 =-rbmp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x3 = dcmplx(x1,x2)
                   a(ii) = a(ii) + x3  
                 elseif ((l.eq.6).and.(m.eq.2)) then
                   aa=16.d0/dsqrt(105.0d0)
                   x1 = ramp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x2 =-rbmp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x3 = dcmplx(x1,x2)
                   a(ii) = a(ii) + x3  
                 elseif ((l.eq.6).and.(m.eq.3)) then
                   aa=8.d0/dsqrt(105.0d0)
                   x1 = ramp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x2 =-rbmp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x3 = dcmplx(x1,x2)
                   a(ii) = a(ii) + x3  
                 elseif ((l.eq.6).and.(m.eq.4)) then
                   aa=16.d0/(3.d0*dsqrt(14.0d0))
                   x1 = ramp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x2 =-rbmp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x3 = dcmplx(x1,x2)
                   a(ii) = a(ii) + x3  
                 elseif ((l.eq.6).and.(m.eq.5)) then
                   aa=8.d0/(3.d0*dsqrt(77.0d0))
                   x1 = ramp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x2 =-rbmp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x3 = dcmplx(x1,x2)
                   a(ii) = a(ii) + x3  
                 elseif ((l.eq.6).and.(m.eq.6)) then
                   aa=16.d0/(dsqrt(231.0d0))
                   x1 = ramp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x2 =-rbmp(l,m)*oplm(i,j,l,m,sn)*stev(l,inn)/aa
                   x3 = dcmplx(x1,x2)
                   a(ii) = a(ii) + x3  
                 endif
              elseif (istevens.eq.2) then !AKQ rK
                   x1 = ramp(l,m)*stev(l,inn)*oplm(i,j,l,m,sn)
                   x2 =-rbmp(l,m)*stev(l,inn)*oplm(i,j,l,m,sn)
                   x3 = dcmplx(x1,x2)
                   a(ii) = a(ii) + x3  
          endif
          endif
    7  continue
   77  continue
          a(ii)=a(ii)+hypar(ii)+hyper(ii)+quad(ii)
          bb(ii) = a(ii)
          if ((i.eq.j).and.(ja.eq.ia)) bb(ii)=a(ii)+rmsa(ia)*0.46686d0*g&
     &(inn)*fclock ! Here, to change the magnetic field
 6    continue
      ix=ixx
c
      info=0
      n=ix
      ldz=idtot
      jobz='n'
      if (ieig.eq.2) jobz='v'
      uplo='u'
c
      call zhpev(jobz,uplo,n,bb,dd,zz,ldz,work,rwork,info)
      if (info.ne.0) then 
        write (3,203)
        stop
      endif
      ecero=dd(1)
      close(7)
c
 203  format (/'     *** LAPACK ERROR *** '/
     + 'problems in the diagonalization process'/
     + 'execution stops.'/)
c 
      return
      end
c
      subroutine esm
c
      implicit double precision (a-h,o-z)
c
      include 'simpre.par'
c
      complex*16 zz(idtot,idtot)
      complex*16 bb(idtot*(idtot+1)/2)
      complex*16 a(idtot*(idtot+1)/2)
      complex*16 work(2*idtot)
c
      dimension plm(6,0:6)
      dimension g(13)
      dimension stev(6,13)
      dimension ro(6,13),rr(6,13)
      dimension dd(idtot) 
      dimension rwork(3*idtot)
      dimension rmsa(idtot)
      dimension rmsv(idtot)
      dimension irelec(idtot)
      dimension irnucl(idtot)
      dimension ramp(6,0:6),rbmp(6,0:6)
      dimension isn(13)
      dimension isv(13)
c
      integer   info,ldz,n
c
      character*7 ele(13)
      character*4 uni(3)
      character jobz,uplo
c
      common /a500/ g
      common /a501/ stev
      common /a503/ ro,rr
      common /a504/ pi
      common /a592/ plm
      common /a601/ ramp,rbmp
      common /rr60/  paso_out
      common /rr110/ a
      common /rr120/ bb
      common /rr132/ dd
      common /rr133/ zz
      common /rr134/ ecero
      common /rr140/ rmsa
      common /rr141/ rmsv
      common /rr21/ temph
      common /rr50/ temp1,temp2,field
      common /i550/ isteptemp
      common /i500/ isn
      common /i502/ isv
      common /i501/ inn
      common /ii50/ ix
      common /aa10/ uni
      common /c002/ ele    
c
      write (3,*)
      write (3,*) '****************************************************'
      write (3,207) uni(iuni)
      write (3,*) '****************************************************'
      write (3,*)                                                       
      write (3,*) '  k   q         Akq <rk>             Bkq            '
      write (3,*) '----------------------------------------------------'
      write (3,*)
c
      info=0
      do 8 l=2,6,2
      do 8 m=0,l
c       
      x11 = stev(l,inn)*ramp(l,m)
      x12 = stev(l,inn)*rbmp(l,m)
c                                  
       x13 = dsqrt(x11**2.d0+x12**2.d0)
       if(x13.gt.eps) then
       if(m.eq.0) then
       write (3,908) l,m,(ramp(l,m)*paso_out),(x11*paso_out)
       else
       write (3,908) l,m,(ramp(l,m)*paso_out),(x11*paso_out)
        if(dabs(x12).gt.eps) then 
        write (3,908) l,-m,(rbmp(l,m)*paso_out),(x12*paso_out)
        elseif(dabs(x12).lt.eps) then
        write (3,908) l,-m,dabs(rbmp(l,m)*paso_out),dabs(x12*paso_out)
        endif
       endif
       else
       continue
       endif
  8    continue
c
      if (info.ne.0) then
      write (3,203)
      stop
      endif
c
      if (iuni.eq.1) paso_out = 1.4387770d0
      if (iuni.eq.2) paso_out = 0.1239841930d0
      if (iuni.eq.3) paso_out = 1.d0
c
      write (3,*)
      write (3,308) uni(iuni)     
      write (3,*)     
      do 260 ie=1,ix 
        promj=0.d0
        promi=0.d0
        do 270 iaa=1,ix
           promj=promj+(abs(zz(iaa,ie))**2)*(rmsa(iaa))  !Expectation Value of J_z
           promi=promi+(abs(zz(iaa,ie))**2)*(rmsv(iaa))  !Expectation Value of I_z
 270     continue
           write(3,508) (dd(ie)-ecero)*paso_out, promj, promi, ie
 260   continue
c
      ixxx = 0
      do 609 istz=-isn(inn),isn(inn),2
        ixxx=ixxx+1
        irelec(ixxx)= istz
 609  continue
      ixxx = 0
      do 608 is1z=-isv(inn),isv(inn),2
        ixxx=ixxx+1
        irnucl(ixxx)= is1z
 608  continue
      write (3,*)
      write (3,408) 
      write (3,*)
      write (3,909) (irnucl(ie1),ie1=1,isv(inn)+1)  !Here, basis elements |m_J,m_I> are written
      write (3,*)  '        2*m_J' 
      do 708 ixxx = 1,isn(inn)+1
       write (3,808) irelec(ixxx),(ixxxx,ixxxx=(isv(inn)+1)*ixxx-isv(inn&
     &),(isv(inn)+1)*ixxx) 
 708  continue
      write (3,*)
c
      write (3,208) uni(iuni) !Here, eigenfunctions and eigenvalues are written
      write (3,*)
      do 26 i=1,ix
       write (3,1010)(dd(i)-ecero)*paso_out
       write (3,909) (irnucl(ie1),ie1=1,isv(inn)+1)
       write (3,*)  '        2*m_J' 
       do 610 ixxx = 1,isn(inn)+1
       write (3,1011) irelec(ixxx),(dble(zz(ie1,i)),ie1=(isv(inn)+1)*ixx&
     &x-isv(inn),(isv(inn)+1)*ixxx) !Real Parts
       write (3,1012) (dble(aimag(zz(ie1,i))),ie1=(isv(inn)+1)*ixxx-isv(&
     &inn),(isv(inn)+1)*ixxx) !Imaginary Parts
       write (3,*)
 610   continue 
  26  continue
c
      write (3,*)
      write (3,209) uni(iuni) !Here, eigenfunctions (modulus square of coefficients) and eigenvalues are written
      write (3,*)
c
      do 27 i=1,ix
       write (3,1010)(dd(i)-ecero)*paso_out
       write (3,909) (irnucl(ie1),ie1=1,isv(inn)+1)
       write (3,*)  '        2*m_J'
        do 611 ixxx = 1,isn(inn)+1
       write (3,1011) irelec(ixxx),(abs(zz(ie1,i))**2,ie1=(isv(inn)+1)*i&
     &xxx-isv(inn),(isv(inn)+1)*ixxx)
       write (3,*)
 611    continue
  27  continue
c
 203  format (/'     *** LAPACK ERROR *** '/
     & 'problems in the diagonalization process'/
     & 'execution stops.'/)
 207  format ('     Stevens Crystal Field Parameters (',a4,')')
 208  format ('Eigenvalues (',a4,') and eigenvectors')
 308  format ('Eigenvalues (',a4,')    Expected J_z    Expected I_z   Ei&
     &genstate')
 408  format ('Basis Functions')
 508  format (f16.6,f16.6,f16.6,I8) 
 209  format ('Eigenvalues (',a4,') and eigenvectors (modulus square)')
 908  format (2i4,2f18.8,'   ',2f18.8,'  ',3f18.8,'  ',3f18.8)
 909  format ('         2*m_I',30I8)
 808  format ('      ',I8,15I8)
1010  format (f16.6)  
1011  format ('     ',I8,'  ',17f10.6)
1012  format ('               ',17f10.6)
 910  format (17(2f10.6))
 911  format ('                ',17(2f10.6))
 912  format ('                ',30f10.2)
 913  format (17(2f10.6))
 914  format ('                   ' f11.7, ' ', f11.7, ' ', f11.7)
 915  format (a3,4f13.7)
c
 999  return
      end
c
      subroutine readwritedata
      implicit double precision (a-h,o-z)
      include 'simpre.par'
c
      dimension isn(13),isv(13)
c
      double precision nmm,nmminp
c
      integer*8 :: itblock,nblock,natomtot,nes,nesinp
      integer*8 :: natom,nim,ia,i,j,k,l,m,n
c
      character*7 ele(13)
      character*9 label(nsp)
      character*11 atom(20)
c
      dimension rmf(nsp,3)
      dimension gl(3),rd(ime,3)
      dimension nmm(20),nes(20),nmminp(imn),nesinp(imn)
      dimension or(3),itblock(imn),rn(imn,3)
      dimension ocup(imn),ihyp(imn),ahyp(imn,3)
c
      common /i500/ isn
      common /i502/ isv
      common /i501/ inn
      common /c002/ ele
      common /de01/ nblock
      common /de02/ itblock
      common /de03/ nmminp
      common /de04/ nesinp
      common /de05/ or
      common /de06/ rn
      common /de07/ ocup
      common /de08/ ihyp
      common /de09/ ahyp
      common /de10/ natom
      common /de11/ nim
      common /de12/ rd
      common /de13/ gl
      common /de14/ nqther
      common /mf01/ label
      common /mf02/ rmf
      common /mf03/ nspr
c
      gl(1)=gx  ! gx
      gl(2)=gy  ! gy
      gl(3)=gz  ! gz
c
c     MAGNETIC FIELD IN SPACE POINTS
c
      if (nmf.eq.1) then
        open(15,file='simpre.mf',status='unknown')   
        read(15,812) nspr 
        do 756 i=1,nspr
          read(15,810) label(i),(rmf(i,j),j=1,3) !i=1 must always be the Magnetic Ion
 756    continue
        close(15)
      endif
c
c     DECOHERENCE
c
      if (idec.eq.1) then
      write(10,*) ' '
      write(10,*) '*******Magnetic Ion (Qubit)*******'
      write(10,*) ' '
      if (inew.eq.0) then
        write(10,828) ele(inn),isn(inn),isv(inn)
      else
        write(10,829) isn(inn),isv(inn)
      endif
      write(10,*) ' '
      write(10,815) gl(1),gl(2),gl(3),coefio
      write(10,*) ' '
      write(10,816) igr,iex,temp
      write(10,*) ' '
      endif
c
c     NUCLEAR SPIN BATH
c
      if ((idecn.eq.1).and.(idec.eq.1)) then
c     Nuclear Lande g Factors and Nuclear Spins
c     http://www.easyspin.org/documentation/isotopetable.html
c     1Hydrogen (protium) nuclei
      nmm(1)= 5.58569468d0         ! 1H  I=1/2
      nes(1)= 1
      atom(1)='1H'
c     2Hydrogen (deuterium) nuclei
      nmm(2)= 0.85743820d0         ! 2H  I=1
      nes(2)= 2
      atom(2)='2H'
c     14Nitrogen nuclei
      nmm(3)= 0.40376100d0         ! 14N I=1
      nes(3)= 2
      atom(3)='14N'
c     Natural Sulphur nuclei
      nmm(4)= 0.00326203d0         ! 33S I=3/2
      nes(4)= 3
      atom(4)='33S'
c     Natural Carbon nuclei
      nmm(5)= 0.01503161d0         ! 13C I=1/2
      nes(5)= 1
      atom(5)='13C'
c     31Phosphorous nuclei
      nmm(6)= 2.26320000d0         ! 31P  I=1/2
      nes(6)= 1
      atom(6)='31P'
c     Natural Chlorine nuclei
      nmm(7)= 0.52567405d0         ! 35Cl+37Cl I=3/2
      nes(7)= 3
      atom(7)='35Cl+37Cl'
c     Natural Potassium nuclei
      nmm(8)= 0.25298781d0         ! 39K+41K I=3/2
      nes(8)= 3
      atom(8)='39K+41K'
c     Natural Tungsten nuclei
      nmm(9)= 0.03371000d0         ! 180-186W I=1/2
      nes(9)= 1
      atom(9)='180-186W'
c     Natural Molybden nuclei
      nmm(10)=-0.09387914d0        ! 95Mo+97Mo I=5/2
      nes(10)= 5
      atom(10)='95Mo+97Mo'
c     19Fluor nuclei
      nmm(11)= 5.25773600d0        ! 19F I=1/2
      nes(11)= 1
      atom(11)='19F'
c     23Sodium nuclei
      nmm(12)= 1.47834800d0        ! 23Na I=3/2
      nes(12)= 3
      atom(12)='23Na'
c     16O+17Oxygen nuclei
      nmm(13)=-0.00028786d0        ! 16O+17O I=5/2
      nes(13)= 5
      atom(13)='16O+17O'
c
      atom(20)='user-def'          ! user-defined nucleus
c
c     Up to 19 types of nucleus can be defined.
c
      open(13,file='simpre.decn',status='unknown')
      read(13,915) (or(i),i=1,3)
      read(13,812) nblock 
      write(10,*) ' '
      write(10,*) '*******NUCLEAR SPIN BATH*******'
      write(10,*) ' '
      write(10,822) (or(i),i=1,3)
      write(10,*) ' '
      write(10,814) nblock
      write(10,*) ' '
      natomtot=0
      do 799 ia=1,nblock 
        read(13,811) itblock(ia),itipo,ihyp(ia),ocup(ia)
        if (itipo.eq.20) then
          read(13,914) nmminp(ia),nesinp(ia)
          write(10,813) ia,itblock(ia),atom(itipo),ocup(ia),nmminp(ia),n&
     &esinp(ia)
        else
          nmminp(ia)=nmm(itipo)
          nesinp(ia)=nes(itipo)
          write(10,813) ia,itblock(ia),atom(itipo),ocup(ia),nmminp(ia),n&
     &esinp(ia)
        endif
        do 809 i=1,itblock(ia) 
          j=i+natomtot
          if (ihyp(ia).eq.1) then
            read(13,915) ahyp(j,1),ahyp(j,2),ahyp(j,3)
            write(10,924) i,ahyp(j,1),ahyp(j,2),ahyp(j,3)
          else
            if (icoorn.eq.0) then
              read(13,915) rn(j,1),rn(j,2),rn(j,3)
            else
              read(13,915) readr,readtheta,readphi
              rn(j,1)=readr*dsin(readtheta)*dcos(readphi)   
              rn(j,2)=readr*dsin(readtheta)*dsin(readphi)  
              rn(j,3)=readr*dcos(readtheta)
            endif
          endif
 809    continue
        natomtot=natomtot+itblock(ia) 
 799  continue
      close(13)
      write(10,*) ' '
      write(10,*) 'The total number of nuclei is: ',natomtot
      write(10,*) ' '
      endif
c
c     ELECTRONIC SPIN BATH
c
      if ((idece.eq.1).and.(idec.eq.1)) then
      write(10,*) ' '
      write(10,*) '*******ELECTRONIC SPIN BATH*******'
      open(23,file='simpre.dece',status='unknown')
      read(23,812) natom 
      if (iopc.eq.1) then
        nim=nint((x/100.0d0)*dble(natom))  
      elseif (iopc.eq.2) then
        nim=nint(dble(natom)/(1.0d0+(ammp/ammd)*(100.0d0/x)))
      elseif (iopc.eq.3) then
        nim=nint(dble(natom)/(1.0d0+(ammp/ammd)*((100.0d0/x)-1.0d0)))
      endif
      nqther=nint((therd/100.0d0)*dble(nim))  
      if (icoord.eq.0) then
        do 750 i=1,natom 
          read(23,915) rd(i,1),rd(i,2),rd(i,3)
 750    continue
      else
        do 753 i=1,natom      
          read(23,915) readr,readtheta,readphi 
          rd(i,1)=readr*dsin(readtheta)*dcos(readphi)   
          rd(i,2)=readr*dsin(readtheta)*dsin(readphi)  
          rd(i,3)=readr*dcos(readtheta)
 753    continue
      endif
      close(23)
      write(10,*) ' '
      if (iopc.eq.1) then
        write(10,830) iopc,x
      else
        write(10,824) ammp,ammd,iopc,x
      endif
      write(10,*) ' '
      write(10,819) natom,nim,nt2
      write(10,*) ' '
      write(10,825) therd,nther,nqther,nim-nqther
      if (nim.eq.natom) then 
        write(10,*) ' '
        write(10,*) ' The number of magnetic ions to be placed coincides&
     & with the initial number of ions.'
        write(10,*) ' Dilution Subroutine will not be used.'
      endif
      write(10,*) ' '
      endif
c
c     WRITING
c
      if (idec.eq.1) then
      write(10,*) ' '
      write(10,*) '*******RESULTS*******'
      write(10,*) ' '
      if ((idecn.eq.0).and.(idece.eq.0)) then
        write(10,*) '   Bz(T)   Gap(GHz)    <Jx>gr    <Jy>gr    <Jz>gr  &
     &  <Jx>ex    <Jy>ex    <Jz>ex'
      elseif ((idecn.eq.1).and.(idece.eq.0)) then
        write(10,*) '   Bz(T)   Gap(GHz)    <Jx>gr    <Jy>gr    <Jz>gr  &
     &  <Jx>ex    <Jy>ex    <Jz>ex    E-n(GHz)      Gamma-n       T2-n(s&
     &)'
      elseif ((idecn.eq.0).and.(idece.eq.1)) then
        write(10,*) '   Bz(T)   Gap(GHz)    <Jx>gr    <Jy>gr    <Jz>gr  &
     &  <Jx>ex    <Jy>ex    <Jz>ex    E-e(GHz)      Gamma-e       T2-e(s&
     &)'
      elseif ((idecn.eq.1).and.(idece.eq.1)) then
        write(10,*) '   Bz(T)   Gap(GHz)    <Jx>gr    <Jy>gr    <Jz>gr  &
     &  <Jx>ex    <Jy>ex    <Jz>ex    E-n(GHz)      Gamma-n       T2-n(s&
     &)       E-e(GHz)      Gamma-e       T2-e(s)      T2-(n+e)(s)'
      endif
      write(10,*) ' '
      endif
c
 810  format (a9,3f12.5)
 811  format (I8,I4,I2,f5.2)
 812  format (I8)
 813  format (' Block ',I8,' has ',I8,' nuclei of ',A11,' with O.F.: ',
     &f5.2,'; g_N= ',f12.5,'; 2*I= ',I8)
 814  format (' Number of blocks: ',I8)
 815  format (' gx= ',f9.5,'; gy= ',f9.5,'; gz= ',f9.5,'; Ion. Coeff.= '&
     &,f8.5)
 816  format (' Qubit Ground State: ',I8,'; Qubit Excited State: ',I8,';&
     & Temperature (K): ',f9.5)
 819  format (' Ions: ',I8,'; Magnetic Ions to be placed: ',I8,'; Diluti&
     &ons: ',I8)
 822  format (' Magnetic Ion (Qubit) Position: ',3f12.5)
 823  format (I4)
 824  format (' Param. Ion Molar Mass (g/mol): ',f12.5,'; Diam. Ion Mola&
     &r Mass (g/mol): ',f12.5,'; Concentration (option ',I2,'):',f9.5,'%&
     &')
 825  format (' Thermal degree: ',f9.5,'; Thermal samplings: ',I8,'; The&
     &rmal electron spins: ',I8,'; Coherent qubits: ',I8)
 828  format (' Lanthanoid: ',A10,' selected, with 2*J=',I4,'; 2*I=',I4)
 829  format (' New Magnetic Ion selected, with 2*J=',I4,'; 2*I =',I4)
 830  format (' Concentration (option ',I2,'):',f9.5,'%')
 914  format (f12.5,I8)
 915  format (3f12.5)
 924  format ('  Nucleus ',I8,' has Ax(MHz)= ',f12.5,'; Ay(MHz)= ',f12.5&
     &,'; Az(MHz)= ',f12.5)
      return
      end
      subroutine dec
      implicit double precision (a-h,o-z)
      include 'simpre.par'
c
      complex*16 zz(idtot,idtot)
      dimension dd(idtot),isn(13),isv(13),calam(3)
c
      character*7 ele(13)
      character*9 label(nsp)
c
      double precision kBmhz,kBcm,muB,muN,mu,nmminp
c
      integer*8 :: nnuctot,itblock,nblock,nesinp,natom,nim,i,j,k,l,m,n
      integer*8, allocatable :: vnale(:),vnale1(:),vnale2(:)
c
      dimension rmf(nsp,3)
      dimension gl(3),expj(2,3)
      dimension rd(ime,3),expel2(idtot,3),ther(3),vrel(3)
      dimension or(3),rn(imn,3),ocup(imn),ihyp(imn),ahyp(imn,3)
      dimension itblock(imn),nmminp(imn),nesinp(imn),exaux(3)
c
      common /a504/ pi
      common /rr132/ dd
      common /rr133/ zz
      common /i500/ isn
      common /i502/ isv
      common /i501/ inn
      common /c002/ ele
      common /RS99/ fclock
      common /de01/ nblock
      common /de02/ itblock
      common /de03/ nmminp
      common /de04/ nesinp
      common /de05/ or
      common /de06/ rn
      common /de07/ ocup
      common /de08/ ihyp
      common /de09/ ahyp
      common /de10/ natom
      common /de11/ nim
      common /de12/ rd
      common /de13/ gl
      common /de14/ nqther
      common /mf01/ label
      common /mf02/ rmf
      common /mf03/ nspr
c
c CONSTANTS
c
      kBmhz=20836.612d0   ! Boltzmann constant in MHz/K
      kBcm=0.69503457d0   ! Boltzmann constant in cm-1/K
      muB=9.2740099940d-4 ! Bohr magneton in Ampere*Ang^2 (J/T=A*m2)
      muN=7.62259328500d0 ! Nuclear magneton in MHz/T
      mu= 12566.370614d0  ! Magnetic Constant in T*Ang/Ampere (T*m/A is 4pi*10e-7)
c
      djota=dble(isn(inn))/2.0d0
c
      if (idec.eq.1) then
c
c QUBIT GAP
c
      deltaMHz=(dd(iex)-dd(igr))*29979.24580d0 !dd is in cm-1 (cm-1 to MHz)
      deltaJ=(dd(iex)-dd(igr))*1.986445824d-23 !dd is in cm-1 (cm-1 to J)
c
c J EXPECTATION VALUES CALCULATION FOR THE TWO STATES OF THE QUBIT
c
      ipaso=iex-igr
      do 332 k=igr,iex,ipaso
        expz=0.0d0
        do 333 j=1,isn(inn)+1
          auxz=0.0d0
          do 334 i=(j-1)*(isv(inn)+1)+1,j*(isv(inn)+1)
            auxz=auxz+abs(zz(i,k))**2
 334      continue
          expz=expz+(dble(j)-1.0d0-djota)*auxz
 333    continue
        expx=0.0d0
        expy=0.0d0
        do 335 j=1,isn(inn)
          auxx=0.0d0
          auxy=0.0d0
          do 336 i=(j-1)*(isv(inn)+1)+1,j*(isv(inn)+1)
            auxx=auxx+dble(dconjg(zz(i+isv(inn)+1,k))*zz(i,k)+zz(i+isv(i&
     &nn)+1,k)*dconjg(zz(i,k)))
            auxy=auxy+dble((0.0d0,-1.0d0)*(dconjg(zz(i+isv(inn)+1,k))*zz&
     &(i,k)-zz(i+isv(inn)+1,k)*dconjg(zz(i,k))))
 336      continue
        expx=expx+dsqrt(djota*(djota+1.0d0)-(dble(j)-1.0d0-djota)*(dble(&
     &j)-djota))*auxx
        expy=expy+dsqrt(djota*(djota+1.0d0)-(dble(j)-1.0d0-djota)*(dble(&
     &j)-djota))*auxy
 335    continue
        if (k.eq.igr) then
          expj(1,3)=expz
          expj(1,1)=0.5d0*expx
          expj(1,2)=0.5d0*expy
        else
          expj(2,3)=expz
          expj(2,1)=0.5d0*expx
          expj(2,2)=0.5d0*expy
        endif
 332  continue
c
      endif
c
c NUCLEAR SPIN BATH DECOHERENCE CALCULATION
c
      if ((idecn.eq.1).and.(idec.eq.1)) then
      En2=0.0d0
      nnuctot=0
      do 810 i=1,nblock 
        sumn=0.0d0
        sumd=0.0d0
        do 800 l=-nesinp(i),nesinp(i),2
          bolfa=dexp((-muN*nmminp(i)*fclock*dble(l))/(2.0d0*kBmhz*temp))
          sumn=sumn+bolfa*((dble(l))**2)
          sumd=sumd+bolfa
 800    continue
        exaux(3)=dsqrt((0.25d0*sumn)/sumd)
        spinn=dble(nesinp(i))/2.0d0
        exaux(1)=dsqrt((spinn*(spinn+1.0d0)-((0.25d0*sumn)/sumd))/2.0d0)
        exaux(2)=exaux(1)
        do 811 j=1,itblock(i)
          k=j+nnuctot
          if (ihyp(i).ne.1) then
            rn(k,1)=rn(k,1)-or(1)
            rn(k,2)=rn(k,2)-or(2)
            rn(k,3)=rn(k,3)-or(3)
            r2=rn(k,1)**2+rn(k,2)**2+rn(k,3)**2
            r3=r2**1.5d0
            auxs=0.0d0
            do 337 ial=1,3
              auxss=0.0d0
              do 338 ibe=1,3
                if (ibe.ne.ial) then
                 auxss=auxss+rn(k,ibe)*gl(ibe)*(expj(2,ibe)-expj(1,ibe))
                endif
 338          continue
              auxs=auxs+(exaux(ial)*((1.0d0-3.0d0*((rn(k,ial)**2)/r2))*g&
     &l(ial)*(expj(2,ial)-expj(1,ial))-3.0d0*(rn(k,ial)/r2)*auxss))**2
 337        continue
            En2=En2+ocup(i)*(coefio**2)*auxs*(((mu*muB*muN*nmminp(i))/(8&
     &.0d0*pi*r3))**2) !En2 is in MHz^2
          else
            e1=ahyp(k,1)*exaux(1)*(expj(2,1)-expj(1,1))
            e2=ahyp(k,2)*exaux(2)*(expj(2,2)-expj(1,2))
            e3=ahyp(k,3)*exaux(3)*(expj(2,3)-expj(1,3))
            En2=En2+ocup(i)*(coefio**2)*0.25d0*(e1**2+e2**2+e3**2) !En2 is in MHz^2
          endif
 811    continue
        nnuctot=nnuctot+itblock(i)
 810  continue
      gamman=2.0d0*(En2/(deltaMHz**2))
      tauns=((0.1591549d-6)*deltaMHz)/En2 !hbar in MHz*s
      endif
c
c ELECTRON SPIN BATH DECOHERENCE CALCULATION
c
      if ((idece.eq.1).or.(nmf.eq.1)) then
c
c J_x,y,z - square expectation value calculation
c
      if((((nim-nqther).gt.0).and.(nqther.gt.0)).or.(nim.eq.nqther).or.(&
     &nmf.eq.1))then
      do 700 k=1,idtot
        expel2(k,3)=0.0d0
        do 701 j=1,isn(inn)+1
          auxz2=0.0d0
          do 702 i=(j-1)*(isv(inn)+1)+1,j*(isv(inn)+1)
            auxz2=auxz2+abs(zz(i,k))**2
 702      continue
          expel2(k,3)=expel2(k,3)+((dble(j)-1.0d0-djota)**2)*auxz2
 701    continue
        auxx2=0.0d0
        do 703 j=1,isn(inn)-1
          auxxs=0.0d0
          do 704 i=(j-1)*(isv(inn)+1)+1,j*(isv(inn)+1)
            auxxs=auxxs+dble(dconjg(zz(i+2*(isv(inn)+1),k))*zz(i,k)+zz(i&
     &+2*(isv(inn)+1),k)*dconjg(zz(i,k)))
 704      continue
        auxx2=auxx2+dsqrt(djota*(djota+1.0d0)-(dble(j)-1.0d0-djota)*(dbl&
     &e(j)-djota))*dsqrt(djota*(djota+1.0d0)-(dble(j)+1.0d0-djota)*(dble&
     &(j)-djota))*auxxs
 703    continue
        expel2(k,1)=0.5d0*(djota*(djota+1.0d0)-expel2(k,3)+0.5d0*auxx2)
        expel2(k,2)=djota*(djota+1.0d0)-expel2(k,3)-expel2(k,1)
 700  continue
      endif
c
c J_x,y,z - thermal expectation value calculation
c
      if((((nim-nqther).gt.0).and.(nqther.gt.0)).or.(nim.eq.nqther).or.(&
     &nmf.eq.1))then
        znum=0.0d0
        xnum=0.0d0
        deno=0.0d0
        do 705 k=1,idtot
          bexp=dexp(-(dd(k)-dd(1))/(kBcm*temp))
          znum=znum+expel2(k,3)*bexp
          xnum=xnum+expel2(k,1)*bexp
          deno=deno+bexp
 705    continue
        ther(3)=dsqrt(znum/deno)
        ther(1)=dsqrt(xnum/deno)
        ther(2)=dsqrt(djota*(djota+1.0d0)-(znum/deno)-(xnum/deno))
        if (itherz.eq.1) then
          ther(3)=thejz
        endif
        if (itherx.eq.1) then
          ther(1)=thejx
        endif
        if (ithery.eq.1) then
          ther(2)=thejy
        endif
      endif
c
c Magnetic field calculations in space points
c
      if (nmf.eq.1) then
        write(14,*) ' '
        write(14,*) '*******Magnetic Field Calculation in Space Points**&
     &*****'
        write(14,*) ' '
        write(14,820) fclock,temp 
        write(14,*) ' '
        write(14,821) gl(1),gl(2),gl(3),ther(1),ther(2),ther(3)
        write(14,*) ' '
        write(14,822) rmf(1,1),rmf(1,2),rmf(1,3) 
        write(14,*) ' '
        cte=9.27400915d-31
        smfa1=(gl(1)*ther(1))**2+(gl(2)*ther(2))**2+(gl(3)*ther(3))**2
        write(14,*) 'Position    Label       x(A)        y(A)        z(A&
     &)      dist(A)       Bx(T)       By(T)       Bz(T)      |B|(T)'
        write(14,*) ' '
        iabc=0             !
        do 812 i=2,nspr
          xpos=rmf(i,1)-rmf(1,1) 
          ypos=rmf(i,2)-rmf(1,2)
          zpos=rmf(i,3)-rmf(1,3)
          r2pos=(xpos**2+ypos**2+zpos**2)*1.0d-20
          r5pos=r2pos**2.5d0
          smfa2=(gl(1)*ther(1)*xpos+gl(2)*ther(2)*ypos+gl(3)*ther(3)*zpo&
     &s)*1.0d-10
         vmfx=(cte/r5pos)*(3.0d0*xpos*1.0d-10*smfa2-r2pos*gl(1)*ther(1))
         vmfy=(cte/r5pos)*(3.0d0*ypos*1.0d-10*smfa2-r2pos*gl(2)*ther(2))
         vmfz=(cte/r5pos)*(3.0d0*zpos*1.0d-10*smfa2-r2pos*gl(3)*ther(3))
         vnomf=(cte/r2pos**2)*dsqrt(3.0d0*(smfa2**2)+smfa1*r2pos)
          write(14,823) i,label(i),rmf(i,1),rmf(i,2),rmf(i,3),dsqrt(r2po&
     &s)*1.0d10,vmfx,vmfy,vmfz,vnomf
          iabc=iabc+1                                               !
          calam(iabc)=vmfz                                          !
          if (iabc.eq.3) then                                       !
            iabc=0                                                  !
            write(14,824) (calam(1)+calam(2)+calam(3))/3.0d0        !
          endif                                                     !
 812    continue
        write(14,*) ' '
      endif
c
c Decoherence calculation
c
      if (idec.eq.1) then
c
      if (nim.gt.1) then
c
      allocate(vnale(nim))
      if ((nim-nqther).gt.0) then
        allocate(vnale1(nim-nqther))
      endif
      if (nqther.gt.0) then
        allocate(vnale2(nqther))
      endif
      if (nim.eq.natom) then 
        do 339 i=1,natom
          vnale(i)=i
 339    continue
      endif
      EQC2s=0.0d0
      ETO2s=0.0d0
      ENQC2s=0.0d0
c
      do 340 k=1,nt2
c
        if (nim.lt.natom) then
          call dilucion(natom,nim,vnale)
        endif
c
        do 341 ik=1,nther
c
        if (((nim-nqther).gt.0).and.(nqther.gt.0)) then
          call dilucion(nim,nim-nqther,vnale1)
          ictr=1
          ij=1
          do while (ictr.le.nqther)
            iflag=0
            il=1
            do while ((iflag.eq.0).and.(il.le.(nim-nqther)))
              if (ij.eq.vnale1(il)) then
                iflag=1
              endif
              il=il+1
            end do
            if (iflag.eq.0) then
              vnale2(ictr)=ij
              ictr=ictr+1
              ij=ij+1
            else
              ij=ij+1
            endif
          end do
        elseif (nqther.eq.0) then
          do 342 ikj=1,nim
            vnale1(ikj)=ikj
 342      continue
        else
          do 343 ikj=1,nim
            vnale2(ikj)=ikj
 343      continue
        endif
c
c       Coherent Qubit - Thermal Electron Spin
c
        if (((nim-nqther).gt.0).and.(nqther.gt.0)) then
        sqc2=0.0d0
        do 708 i=1,nim-nqther
          m=vnale(vnale1(i))
          do 711 j=1,nqther
            n=vnale(vnale2(j))
            vrel(1)=rd(m,1)-rd(n,1)
            vrel(2)=rd(m,2)-rd(n,2)
            vrel(3)=rd(m,3)-rd(n,3)
            r2=vrel(1)**2+vrel(2)**2+vrel(3)**2
            r3=r2**1.5d0
            sxyz=0.0d0         
            do 709 ial=1,3
              sxyzaux=0.0d0
              do 710 ibe=1,3
                if (ibe.ne.ial) then              
                  sxyzaux=sxyzaux+gl(ibe)*vrel(ibe)*(expj(2,ibe)-expj(1,&
     &ibe))
                endif
 710          continue
              sxyz=sxyz+(gl(ial)*ther(ial)*((1.0d0-3.0d0*(((vrel(ial))**&
     &2)/r2))*gl(ial)*(expj(2,ial)-expj(1,ial))-3.0d0*(vrel(ial)/r2)*sxy&
     &zaux))**2
 709        continue
          sqc2=sqc2+sxyz*(((mu*muB*muB)/(8.0d0*pi*r3))**2) 
 711      continue
 708    continue
        EQC2s=EQC2s+(sqc2*1.0d-40)*((1.509190205d27)**2) !J^2 to MHz^2
        endif
c
c       Coherent Qubit - Coherent Qubit
c
        if ((nim-nqther).gt.1) then
        sto2=0.0d0
        do 712 i=1,nim-nqther-1
          m=vnale(vnale1(i))
          do 713 j=i+1,nim-nqther
            n=vnale(vnale1(j))
            vrel(1)=rd(m,1)-rd(n,1)
            vrel(2)=rd(m,2)-rd(n,2)
            vrel(3)=rd(m,3)-rd(n,3)
            r2=vrel(1)**2+vrel(2)**2+vrel(3)**2
            r5=r2**2.5d0
            sxyz=0.0d0         
            do 714 ial=1,3
              sxyzaux=0.0d0
              do 715 ibe=1,3
                if (ibe.ne.ial) then              
                  sxyzaux=sxyzaux+gl(ibe)*vrel(ibe)*(expj(2,ibe)*expj(1,&
     &ial)-expj(1,ibe)*expj(2,ial))
                endif
 715          continue
              sxyz=sxyz+(gl(ial)*vrel(ial)*sxyzaux)**2
 714        continue
          sto2=sto2+sxyz*(((3.0d0*mu*muB*muB)/(8.0d0*pi*r5))**2) 
 713      continue
 712    continue
        ETO2s=ETO2s+(sto2*1.0d-40)*((1.509190205d27)**2) !J^2 to MHz^2
        endif
c
c       Thermal Electron Spin - Thermal Electron Spin
c
        if (nqther.gt.1) then
        snqc2=0.0d0
        do 751 i=1,nqther-1
          m=vnale(vnale2(i))
          do 752 j=i+1,nqther
            n=vnale(vnale2(j))
            vrel(1)=rd(m,1)-rd(n,1)
            vrel(2)=rd(m,2)-rd(n,2)
            vrel(3)=rd(m,3)-rd(n,3)
            r2=vrel(1)**2+vrel(2)**2+vrel(3)**2
            r3=r2**1.5d0
            sxyz=0.0d0
            do 706 ial=1,3
              sxyzaux=0.0d0
              do 707 ibe=1,3
                if (ibe.ne.ial) then
                  sxyzaux=sxyzaux+gl(ibe)*vrel(ibe)*ther(ibe)
                endif
 707          continue
              sxyz=sxyz+(gl(ial)*ther(ial)*((1.0d0-3.0d0*(((vrel(ial))**&
     &2)/r2))*gl(ial)*ther(ial)-3.0d0*(vrel(ial)/r2)*sxyzaux))**2
 706        continue
            snqc2=snqc2+sxyz*(((mu*muB*muB)/(4.0d0*pi*r3))**2) 
 752      continue
 751    continue
        ENQC2s=ENQC2s+(snqc2*1.0d-40)*((1.509190205d27)**2) !J^2 to MHz^2
        endif
c
 341    continue
c
 340  continue
c
      Ed2mean=((EQC2s/(nim-nqther)+ETO2s/(nim-nqther)+ENQC2s/nqther)/(db&
     &le(nt2*nther)))*(coefio**2) !MHz^2
      gdmean=2.0d0*(Ed2mean/(deltaMHz**2))
      tauds=((0.1591549d-6)*deltaMHz)/Ed2mean !hbar in MHz*s
c
      else
        write(10,*) ' '
        write(10,*) 'No magnetic ions. Concentration too low.'
        return
      endif
c
      endif
c
      endif
c
      if (idec.eq.1) then
c
c     WRITING
c
      if ((idecn.eq.0).and.(idece.eq.0)) then
        write(10,816) fclock,deltaMHz/1000.0d0,expj(1,1),expj(1,2),expj(&
     &1,3),expj(2,1),expj(2,2),expj(2,3)
      elseif ((idecn.eq.1).and.(idece.eq.0)) then
        write(10,817) fclock,deltaMHz/1000.0d0,expj(1,1),expj(1,2),expj(&
     &1,3),expj(2,1),expj(2,2),expj(2,3),dsqrt(En2)/1.0d3,gamman,tauns
      elseif ((idecn.eq.0).and.(idece.eq.1)) then
        write(10,818) fclock,deltaMHz/1000.0d0,expj(1,1),expj(1,2),expj(&
     &1,3),expj(2,1),expj(2,2),expj(2,3),dsqrt(Ed2mean)/1.0d3,gdmean,tau&
     &ds
      elseif ((idecn.eq.1).and.(idece.eq.1)) then
        write(10,819) fclock,deltaMHz/1000.0d0,expj(1,1),expj(1,2),expj(&
     &1,3),expj(2,1),expj(2,2),expj(2,3),dsqrt(En2)/1.0d3,gamman,tauns,d&
     &sqrt(Ed2mean)/1.0d3,gdmean,tauds,1.0d0/((1.0d0/tauns)+(1.0d0/tauds&
     &))
      endif
c
      endif
c
 816  format (8f10.5)
 817  format (8f10.5,'  ',ES12.5E3,'  ',ES12.5E3,'  ',ES12.5E3)
 818  format (8f10.5,'  ',ES12.5E3,'  ',ES12.5E3,'  ',ES12.5E3)
 819  format (8f10.5,'  ',ES12.5E3,'  ',ES12.5E3,'  ',ES12.5E3,'  ',ES12&
     &.5E3,'  ',ES12.5E3,'  ',ES12.5E3,'  ',ES12.5E3)
 820  format (' External Magnetic Field (T): ',f9.5,'; Temperature (K): &
     &',f9.5)
 821  format (' gx=',f9.5,'; gy=',f9.5,'; gz=',f9.5,'; <Jx>th=',f9.5,'; &
     &<Jy>th=',f9.5,'; <Jz>th=',f9.5)
 822  format (' Magnetic Ion Position: x(A)= ',f12.5,'; y(A)= ',f12.5,';&
     & z(A)= ',f12.5)
 823  format (' ',I8,a9,7f12.5,ES16.5E3)
 824  format (f12.5)   !
      return
      end
c
      subroutine dilucion(natom,nim,vnale)
        IMPLICIT NONE
        INTEGER*8 :: natom,c1,nim,c2,exito1,exito2,aux
        INTEGER*8 :: vnale(nim)
        REAL*8 :: r
        c1=0
        call init_random_seed()
        DO WHILE (c1.lt.nim)
          IF (c1.eq.0) THEN 
            call random_number(r)
            c1=c1+1
            vnale(c1)=1.0d0+dble(natom)*r
          ELSE 
            exito1=0 
            DO WHILE(exito1.eq.0)
              call random_number(r)
              aux=1.0d0+dble(natom)*r
              c2=1
              exito2=0
              DO WHILE ((c2.le.c1).and.(exito2.eq.0))
                IF (aux.eq.vnale(c2)) THEN 
                  exito2=1
                ENDIF
                c2=c2+1
              END DO           
              IF (exito2.eq.0) THEN
                exito1=1  
              ENDIF
            END DO
            c1=c1+1
            vnale(c1)=aux
          ENDIF
        END DO
        call Sorting(vnale,nim)
      end subroutine
c
      subroutine init_random_seed()
        use iso_fortran_env, only: int64
        implicit none
        integer, allocatable :: seed(:)
        integer :: i, n, un, istat, dt(8), pid
        integer(int64) :: t
        call random_seed(size=n)
        allocate(seed(n))
        open(newunit=un, file="/dev/urandom", access="stream",          &
     &form="unformatted", action="read", status="old", iostat=istat)
        if (istat==0) then
           read(un) seed
           close(un)
        else
           call system_clock(t)
           if (t==0) then
              call date_and_time(values=dt)
              t= (dt(1) - 1970) * 365_int64 * 24 * 60 * 60 * 1000       &
     &+ dt(2) * 31_int64 * 24 * 60 * 60 * 1000                          &
     &+ dt(3) * 24_int64 * 60 * 60 * 1000                               &
     &+ dt(5) * 60 * 60 * 1000                                          &
     &+ dt(6) * 60 * 1000 + dt(7) * 1000 + dt(8)
           endif
           pid = getpid()
           t=ieor(t, int(pid, kind(t)))
           do i = 1, n
              seed(i) = lcg(t)
           end do
        endif
        call random_seed(put=seed)
      contains
        function lcg(s)
          integer :: lcg
          integer(int64) :: s
          if (s==0) then
             s = 104729
          else
             s = mod(s, 4294967296_int64)
          endif
          s = mod(s * 279470273_int64, 4294967291_int64)
          lcg = int(mod(s, int(huge(0), int64)), kind(0))
        end function lcg
      end subroutine init_random_seed
c
      subroutine  Sorting(InputData,ActualSize)
      implicit  none
      integer*8 :: ActualSize
      integer*8 :: i
      integer*8, dimension(1:ActualSize) :: InputData
      call  Sort(InputData, ActualSize)
      contains
      integer function  FindMinimum(x, Start, End)
      implicit  none
      integer*8, dimension(1:), intent(in) :: x
      integer*8, intent(in)                :: Start, End
      integer*8                            :: Minimum
      integer*8                            :: Location
      integer*8                            :: i
      Minimum  = x(Start)		! assume the first is the min
      Location = Start			! record its position
      do i = Start+1, End		! start with next elements
         if (x(i) < Minimum) then	!   if x(i) less than the min?
            Minimum  = x(i)		!      Yes, a new minimum found
            Location = i                !      record its position
         end if
      end do
      FindMinimum = Location        	! return the position
      end function  FindMinimum
      subroutine  Swap(a, b)
      implicit  none
      integer*8, intent(inout) :: a, b
      integer*8                :: Temp
      Temp = a
      a    = b
      b    = Temp
      end subroutine  Swap
      subroutine  Sort(x, Size)
      implicit  none
      integer*8, dimension(1:), intent(inout) :: x
      integer*8, intent(in)                   :: Size
      integer*8                               :: i
      integer*8                               :: Location
      do i = 1, Size-1			! except for the last
         Location = FindMinimum(x, i, Size)	! find min from this to last
         call  Swap(x(i), x(Location))	! swap this and the minimum
      end do
      end subroutine  Sort
      end subroutine  Sorting
c
      subroutine sus                                           
c                                                              
      implicit double precision (a-h,o-z)                      
c                                                              
      include 'simpre.par'                                       
c                                                                                                   
      complex*16 zz(idtot,idtot)
      complex*16 bb(idtot*(idtot+1)/2)
      complex*16 a(idtot*(idtot+1)/2)
      complex*16 work(2*idtot)  
c
      dimension dd(idtot)                    
      dimension rmsa(idtot)
      dimension rmsv(idtot)
      dimension zeex(idtot*(idtot+1)/2),zeey(idtot*(idtot+1)/2)
      dimension zeez(idtot*(idtot+1)/2)                                 
      dimension rwork(3*idtot)                                 
      dimension tintt(3),tintb(3),tint(3)                
      dimension efie(idtot,3,3),slop(idtot,3)              
      dimension isn(13)
      dimension isv(13)
c                                                               
      character jobz,uplo                                      
      integer   info,ldz,n                                     
c     
      common /a504/ pi                                                  
      common /rr50/ temp1,temp2,field
      common /rr110/ a
      common /rr133/ zz  
      common /rr134/ ecero                              
      common /rr150/ zeex,zeey,zeez
      common /rr132/ dd
      common /rr140/ rmsa
      common /rr141/ rmsv
      common /i550/ isteptemp
      common /i500/ isn
      common /i502/ isv
      common /i501/ inn
      common /ii50/ ix                                                  
c
      write (8,917)  temp1,temp2,isteptemp 
      write (8,918)  field/1000.d0 
      write (8,*)                                                       
      write (8,*) '      T (K)       XzT (emuK/mol)   XxT (emuK/mol)  
     &   XyT (emuK/mol)  XavT (emuK/mol)    ' 
      write (8,*) 
c
      jobz='n'                                                 
      uplo='u'                                                 
      n   = ix                                                 
      ldz = idtot
      an    = 6.0225d23
      ergcm = 1.9863d-16
      xk    = 6.950301d-1
      beta  = 4.6685739d-5      
      hf    = field*10.d0      
      paso1 = xk
      paso =  1.4387770d0     
c                               
      if (isus.eq.0) goto 8    
c                               
      itheta = 1               
      iphi   = 2                                              
c                                                              
      l1 = 1                                                
c                                                              
      jj = 0                                                   
        do 2 l=0,itheta*l1                                     
        ang = pi*l/(2.d0*l1)                                   
        k1=iphi*l                                              
        if (ang.gt.pi/2.d0) k1=iphi*(2*l1-l)                   
        do 2 k=0,k1                                            
        if (iphi.ne.0.and.k.eq.k1.and.k.ne.0) goto 2           
        ang1 = 0.d0                                            
        if (k.ne.0) ang1 = pi*k/(2.d0*l)                       
 777    format (2i4,2f12.6)
        jj=jj+1   
c                                                              
        hz = dcos(ang)                                         
        hx = dsin(ang)*dcos(ang1)                              
        hy = dsin(ang)*dsin(ang1)  
c
      do 3 m=1,3                                               
      ii=0                                                     
      do 4 i=1,ix                                               
      do 4 j=1,i                                               
       ii=ii+1                                                    
      bb(ii)=(0.d0,0.d0)                                       
 4    continue                                                 
c                                                              
      if (m.eq.1) ha=hf-10.d0                                  
      if (m.eq.2) ha=hf                                        
      if (m.eq.3) ha=hf+10.d0                                
c                                                              
      ii=0                                                     
      do 5 i=1,ix                                               
      do 5 j=1,i                                               
      ii=ii+1                                                  
      a1 = (zeez(ii)*hz+zeex(ii)*hx)*ha*beta        
      if (dabs(a1).lt.eps) a1=0.d0                             
      a2 = zeey(ii)*hy*ha*beta                               
      if (dabs(a2).lt.eps) a2=0.d0                          
      bb(ii) = a(ii)*paso*paso1 + cmplx(a1,a2)            
 5    continue                                                 
c                                                              
      call zhpev(jobz,uplo,n,bb,dd,zz,ldz,work,rwork,info)     
c                                                              
      do 6 i3=1,ix                                              
      efie(i3,m,jj) = dd(i3)                                  
 6    continue                                                 
c                                                              
      if (m.ne.3) goto 3                                       
c                                                              
      do 7 i1=1,ix                                              
      s1 = (efie(i1,2,jj)-efie(i1,1,jj))/10.d0                 
      s2 = (efie(i1,3,jj)-efie(i1,2,jj))/10.d0                
      slop(i1,jj) = -ergcm*0.5d0*(s1+s2)                       
 7    continue                                                 
c                                                              
 3    continue                                                 
 2    continue           
      ii=0                                                     
      do 9 i=1,ix                                               
      do 9 j=1,i                                               
        ii=ii+1                                                    
      bb(ii) = a(ii)                                           
      if (abs(bb(ii)).lt.eps) bb(ii)=0.d0                      
 9    continue                                                 
c                                                            
      call zhpev(jobz,uplo,n,bb,dd,zz,ldz,work,rwork,info)     
c                                                              
      do 10 i=2,ix                                              
      dd(i)=dd(i)-dd(1)                                        
 10   continue                                                 
      dd(1)=0.d0 
c                                                                                                                                                      
      aaa=dlog(temp2/temp1)/dble(isteptemp-1.d0)
      aaa=dexp(aaa)
c
      te=temp1
      do 12 item=1,isteptemp
      if (item.eq.1) te=temp1/aaa        
      te=te*aaa
      do 13 iv=1,3                                          
      tintt(iv) = 0.d0                                         
      tintb(iv) = 0.d0                                         
      tint(iv)  = 0.d0                                         
 13   continue                                                 
c                                                              
      jj = 0                                                   
        do 14 l=0,itheta*l1                                    
        ang = pi*l/(2.d0*l1)                                   
        k1=iphi*l                                              
        if (ang.gt.pi/2.d0) k1=iphi*(2*l1-l)                   
        do 14 k=0,k1                                           
        if (iphi.ne.0.and.k.eq.k1.and.k.ne.0) goto 14          
        ang1 = 0.d0                                            
        if (k.ne.0) ang1 = pi*k/(2.d0*l) 
        jj=jj+1                                                
      do 15 ie=1,ix                                             
      r=(efie(ie,2,jj)-efie(1,2,jj))/(te*xk)                   
      iii=abs(idint(-r/100.d0))                                
      rr=dexp(-r/(iii+1))**(iii+1)                             
      tintt(jj) = tintt(jj)+slop(ie,jj)*rr                     
      tintb(jj) = tintb(jj)+rr                                 
 15   continue                                                 
 14   continue                                                 
c                                                              
      susc = 0.d0                                              
      peso1 = 0.d0                                             
      jj = 0                                                   
        do 16 l=0,itheta*l1                                    
        ang = pi*l/(2.d0*l1)                                   
        k1=iphi*l                                              
        if (ang.gt.pi/2.d0) k1=iphi*(2*l1-l)                   
        do 16 k=0,k1                                           
        if (iphi.ne.0.and.k.eq.k1.and.k.ne.0) goto 16          
        ang1 = 0.d0                                            
        if (k.ne.0) ang1 = pi*k/(2.d0*k1)    
        jj=jj+1                                                
        peso = 1.d0                                            
        peso1 = peso1 + peso                                  
        tint(jj)=(an/hf)*te*tintt(jj)/tintb(jj)                
        susc = susc+peso*tint(jj)                          
 16   continue
c
      susce=susc/peso1 
      write (8,103) te,tint(1),tint(2),tint(3),susce  
c
 12   continue             
c
 103  format (f12.2,4f18.6)  
 917  format ('Magnetic susceptibility from ',f9.3,' K to ',f9.3,' K , n
     &umber of points:',i4,',')
 918  format('at a magnetic field equal to',f7.3,' T')  
 8    continue
c                                                                                                
      return              
      end                
c
      subroutine mag
c
      implicit double precision (a-h,o-z)
c
      include 'simpre.par'
c
      complex*16 zz(idtot,idtot)
      complex*16 a(idtot*(idtot+1)/2)
      complex*16 work(2*idtot)
      complex*16 bb(idtot*(idtot+1)/2)
c
      dimension dd(idtot) 
      dimension zeex(idtot*(idtot+1)/2),zeey(idtot*(idtot+1)/2)
      dimension zeez(idtot*(idtot+1)/2)
      dimension dmag(50000)     
      dimension rwork(3*idtot)
      character jobz,uplo
      integer   info,ldz,n
c
      common /a504/ pi
      common /rr110/ a
      common /rr120/ bb
      common /rr21/ temph
      common /rr150/ zeex,zeey,zeez
      common /ii50/ ix
      common /ii22/ icammaxh,icamstph,iangh 
      common /i500/ isn
      common /i502/ isv
      common /i501/ inn
c
      write (9,918) temph,icammaxh/1000.d0,icamstph/1000.d0
      write (9,919) 90.d0/iangh
      write (9,*)                                                  
      write (9,*) '      H (T)           Mz (bm)           Mx (bm)  
     &     My (bm)           Mav(bm) ' 
      write (9,*)   
c
 918   format ('Magnetization at ',f9.3,' K until ',f9.3,' T with a step
     & of: ',f9.3,' T,') 
 919   format ('with an integration angle of ',f9.4,'')
c
      cons = 1.488786d0
      paso = 1.4387770d0
c 
      n=ix
      ldz=idtot
      jobz='n'
      uplo='u'
      te=  temph
c 
      itheta = 2   
      iphi   = 4   
c 
      l1 = iangh
c
      do 7 ihf=0,icammaxh,icamstph
      hh=ihf/1000.d0
      hmax = hh+1.d0/1000.d0
c
      jj = 0
      do 5 l=0,itheta*l1
        ang = pi*l/(2.d0*l1)
        k1=iphi*l
        if (ang.gt.pi/2.d0) k1=iphi*(2*l1-l)
        do 5 k=0,k1
       if (iphi.eq.4.and.k.eq.k1.and.(l.ne.0.and.l.ne.itheta*l1)) goto 5
          ang1 = 0.d0
        if (k.ne.0) ang1 = pi*k/(2.d0*l)
        if (k.ne.0.and.l.gt.l1) ang1 = pi*k/(2.d0*(2*l1-l))
          jj=jj+1
      hz = dcos(ang)
      hx = dsin(ang)*dcos(ang1)
      hy = dsin(ang)*dsin(ang1)
      ii=0
      do 1 i=1,ix
      do 1 j=1,i
       ii=ii+1  
      a1 = zeez(ii)*hz*hh/cons+zeex(ii)*hx*hh/cons
      if (dabs(a1).lt.eps) a1=0.d0
      a2 = zeey(ii)*hy*hh/cons
      if (dabs(a2).lt.eps) a2=0.d0
      bb(ii) = a(ii)*paso + CMPLX(a1,a2)
 1    continue
c
      call zhpev(jobz,uplo,n,bb,dd,zz,ldz,work,rwork,info)
c
      z1=0.d0
c
      ecero=dd(1)
      do 2 ie=2,ix
      dd(ie) = dd(ie)-ecero
      sd1=-dd(ie)/te
      iii=abs(idint(sd1/150.d0))
      z1=z1+dexp(sd1/(iii+1))**(iii+1)
 2    continue
      z1=z1+1
c
      z1=dlog(z1)
      ii=0
c
      do 3 i=1,ix
      do 3 j=1,i
         ii=ii+1  
      a1 = zeez(ii)*hz*hmax/cons+zeex(ii)*hx*hmax/cons
      if (dabs(a1).lt.eps) a1=0.d0
      a2 = zeey(ii)*hy*hmax/cons
      if (dabs(a2).lt.eps) a2=0.d0
      bb(ii) = a(ii)*paso + CMPLX(a1,a2)
 3    continue
c
      call zhpev(jobz,uplo,n,bb,dd,zz,ldz,work,rwork,info)
c
      z2=0.d0
 777  format (12f16.8)
c
      do 4 ie=1,ix
      dd(ie)=dd(ie)-ecero
      sd2=-dd(ie)/te
      iii=abs(idint(sd2/150.d0))
      z2=z2+dexp(sd2/(iii+1))**(iii+1)
 4    continue
c
      z2=dlog(z2)
c
      dmag(jj)= cons*te*(z2-z1)/(hmax-hh)
c
 5    continue
c
      jmax=jj
      dmag(jmax+1)=0.d0
      peso1 = 0.d0
      jj = 0
      do 55 l=0,itheta*l1
        ang = pi*l/(2.d0*l1)
        k1=iphi*l
        if (ang.gt.pi/2.d0) k1=iphi*(2*l1-l)
        do 55 k=0,k1
      if (iphi.eq.4.and.k.eq.k1.and.(l.ne.0.and.l.ne.itheta*l1)) goto 55
          ang1 = 0.d0
        if (k.ne.0) ang1 = pi*k/(2.d0*l)
        if (k.ne.0.and.l.gt.l1) ang1 = pi*k/(2.d0*(2*l1-l))
          jj=jj+1
c
        peso = 1.d0
        peso1 = peso1 + peso
c
      dmag(jmax+1)=dmag(jmax+1)+dmag(jj)*peso
c
 110    format (6f10.6)
c
 55   continue
c
      dmag(jmax+1)=dmag(jmax+1)/peso1

c
       write (9,100) hh,dmag(1),dmag(2*(l1*(l1-1)+1)),
     &              dmag(2*(l1*(l1-1)+1)+l1),dmag(jmax+1)
c
 7    continue
c
 100  format (f12.4,4f18.6)
c
      return
      end
c
      function ylm(l,m,theta,phi)
      implicit double precision (a-h,o-z)
c
      complex*16 cc,ylm
c
      dimension fac(-1:60) 
c
      common /a504/ pi
      common /rr180/ fac
c
      ylm = 0.d0
      aa = dsqrt((2.d0*l+1.d0)*fac(l-m)/(4.d0*pi*fac(l+m)))
      bb = plgndr(l,m,dcos(theta))
      cc = DCMPLX(0,m*phi)
      cc = zexp(cc)
      ylm = aa*bb*cc
c
      return
      end
c
       function plgndr(l,m,x)
c
       implicit double precision (a-h,o-z)
c
       plgndr = 0.d0
       if (m.lt.0.or.m.gt.l.or.abs(x).gt.1.d0) then
         write (3,*) 'bad arguments in plgndr'
         goto 888
       endif
       pmm=1.d0
       if(m.gt.0) then
         somx2=dsqrt((1.d0-x)*(1.d0+x))
         fact=1.d0
         do 11 i=1,m
           pmm=-pmm*fact*somx2
           fact=fact+2.d0
 11      continue
       endif
       if (l.eq.m) then
         plgndr=pmm
       else
         pmmp1=x*(2*m+1)*pmm
         if (l.eq.m+1) then
           plgndr=pmmp1
         else
           do 12 ll=m+2,l
             pll=(x*(2*ll-1)*pmmp1-(ll+m-1)*pmm)/(ll-m)
             pmm=pmmp1
             pmmp1=pll
 12        continue
           plgndr=pll
         endif
       endif
c
 888   return
       end
c
      function oplm(i,j,l,m,sn)
c
      implicit double precision (a-h,o-z)
c
      include 'simpre.par'
c
      dimension a1(idtot),a2(idtot),a3(idtot),a4(idtot),
     &          a5(idtot),a6(idtot)
      dimension sme1(idtot),sma1(idtot),sma2(idtot)
      dimension sma3(idtot),sma4(idtot),sma5(idtot),sma6(idtot)
      dimension rmsa(idtot)
      dimension rmsv(idtot)
      dimension isn(13)
      dimension isv(13)
c
      common /op01/ sd,a1,a2,a3,a4,a5,a6,sme1
      common /op02/ s1,s2,s3
      common /op03/ sma1,sma2,sma3,sma4,sma5,sma6
      common /rr140/ rmsa
      common /rr141/ rmsv
      common /i500/ isn
      common /i502/ isv
c
      oplm = 0.d0
c 20  
        if (l.eq.2.and.m.eq.0) then
          oplm = 3.d0*a1(j)**2-s1
          goto 125
        endif
c 40 
        if (l.eq.4.and.m.eq.0) then
          oplm = 35*a4(j)-30*s1*a1(j)**2+25*a2(j)-6*s1+3*s2
          goto 125
        endif
c 60  
        if (l.eq.6.and.m.eq.0) then
          oplm = 231*a6(j)-315*s1*a4(j)+735*a4(j)+105*a2(j)*s2
     &       -525*s1*a2(j)+294*a2(j)-5.d0*s3+40*s2-60*s1
          goto 125
        endif
c 22
        if (l.eq.2.and.m.eq.2) then
          oplm = 0.5d0*sma2(j)
          goto 125
        endif
c 42
        if (l.eq.4.and.m.eq.2) then
          oplm = 0.25d0*(7*a2(j+2)-s1-5)*sma2(j)
          oplm = oplm + 0.25d0*sma2(j)*(7*a2(j)-s1-5)
          goto 125
        endif
c 62  
        if (l.eq.6.and.m.eq.2) then
          oplm = 0.25d0*(33*a4(j+2)-18*a2(j+2)*s1-123*a2(j+2)+
     &             s2+10*s1+102)*sma2(j)
          oplm = oplm + 0.25d0*sma2(j)*(33*a4(j)-18*a2(j)*s1-
     &             123*a2(j)+s2+10*s1+102)
          goto 125
        endif
c 44
        if (l.eq.4.and.m.eq.4) then
          oplm = 0.5d0*sma4(j)
          goto 125
        endif
c 64
        if (l.eq.6.and.m.eq.4) then
          oplm = 0.25d0*(11*a2(j+4)-s1-38)*sma4(j)
          oplm = oplm + 0.25d0*sma4(j)*(11*a2(j)-s1-38)
          goto 125
        endif
c 66
        if (l.eq.6.and.m.eq.6) then
          oplm = 0.5d0*sma6(j)
          goto 125
        endif
c 43
        if (l.eq.4.and.m.eq.3) then
          oplm = 0.25d0*a1(j+3)*sma3(j)
          oplm = oplm + 0.25d0*sma3(j)*a1(j)
          goto 125
        endif
c 63
        if (l.eq.6.and.m.eq.3) then
          oplm= 0.25d0*(11*a3(j+3)-3*a1(j+3)*s1-59*a1(j+3))*sma3(j)
          oplm=oplm + 0.25d0*sma3(j)*(11*a3(j)-3*a1(j)*s1-59*a1(j))
          goto 125
        endif
c 21
        if (l.eq.2.and.m.eq.1) then
          oplm = 0.25d0*a1(j+1)*sma1(j)
          oplm = oplm + 0.25d0*sma1(j)*a1(j)
          goto 125
        endif
c 41
        if (l.eq.4.and.m.eq.1) then
          oplm = 0.25d0*(7*a3(j+1)-3*s1*a1(j+1)-a1(j+1))*sma1(j)
          oplm = oplm + 0.25d0*sma1(j)*(7*a3(j)-3*s1*a1(j)-a1(j))
          goto 125
        endif
c 61
        if (l.eq.6.and.m.eq.1) then
          oplm = 0.25d0*
     &  (33*a5(j+1)-(30*s1-15)*a3(j+1)+(5*s2-10*s1+12)*a1(j+1))*sma1(j)
          oplm = oplm + 0.25d0*sma1(j)*
     &  (33*a5(j)-(30*s1-15)*a3(j)+(5*s2-10*s1+12)*a1(j))
          goto 125
        endif
c 65
        if (l.eq.6.and.m.eq.5) then
          oplm = 0.25d0*a1(j+5)*sma5(j)
          oplm = oplm + 0.25d0*sma5(j)*a1(j)
          goto 125
        endif
c
 913  format (10f10.2,6f16.8)
c
 125  return
      end
c
      subroutine hypa(i,j,ii)
c      
      implicit double precision (A-H,O-Z)
      include 'simpre.par'
c
      dimension rmsa(idtot)
      dimension rmsv(idtot)
      dimension isn(13)
      dimension isv(13)
      complex*16 hyper(idtot*(idtot+1)/2),hypar(idtot*(idtot+1)/2) ! Hyperfine Matrices
c
      common /rr140/ rmsa
      common /rr141/ rmsv
      common /i500/ isn
      common /i502/ isv
      common /i501/ inn
      common /ii50/ ix
      common /RR16/ hyper,hypar
      hypar(:) = (0.d0,0.d0)
      ii=0
      do 1 i=1,ix
        J=I
        ii=((i*(i-1))/2)+J
        a2 =  ahfz*rmsa(i)*rmsv(i)
        hypar(ii)=hypar(ii)+a2 
 1    continue  
      return
      end
c      
      subroutine hype(i,j,ii)
c     
      implicit double precision (A-H,O-Z)
      include 'simpre.par'
c
      dimension rmsa(idtot)
      dimension rmsv(idtot)
      dimension isn(13)
      dimension isv(13)
      complex*16 hyper(idtot*(idtot+1)/2),hypar(idtot*(idtot+1)/2) ! Hyperfine Matrices
c
      common /rr140/ rmsa
      common /rr141/ rmsv
      common /i500/ isn
      common /i502/ isv
      common /i501/ inn
      common /ii50/ ix
      common /RR16/ hyper,hypar
c
      hyper(:) = (0.d0,0.d0)
      ii=0
      do 1 i=1,ix
      do 2 j=1,i
        ii=((i*(i-1))/2)+J
        hyper(ii)=0.d0
c
        if ((rmsa(i).eq.(rmsa(j)-1)).and.(rmsv(i).eq.(rmsv(j)+1))) then
          sd = isn(inn)/2.d0
          sm = rmsv(i)
          a1 = dsqrt((sd+sm)*(sd-sm+1.d0))
          sd = isn(inn)/2.d0
          sm = rmsa(i)
          a2 = dsqrt((sd-sm)*(sd+sm+1.d0))
          hyper(ii) = hyper(ii) + a1*a2*ahfxy/2.d0
        endif
c
        if ((rmsa(i).eq.(rmsa(j)+1)).and.(rmsv(i).eq.(rmsv(j)-1))) then
          sd = isv(inn)/2.d0
          sm = rmsv(i)
          a1 = dsqrt((sd-sm)*(sd+sm+1.d0))
          sd = isn(inn)/2.d0
          sm = rmsa(i)
          a2 = dsqrt((sd+sm)*(sd-sm+1.d0))
          hyper(ii) = hyper(ii) + a1*a2*ahfxy/2.d0
        endif
 2    continue   
 1    continue
      return
      end
c       
      subroutine quada(i,j,ii)
c      
      implicit double precision (A-H,O-Z)
      include 'simpre.par'
c
      dimension rmsa(idtot)
      dimension rmsv(idtot)
      dimension isn(13)
      dimension isv(13)
      complex*16 quad(idtot*(idtot+1)/2) ! Quadrupolar Matrix
c
      common /aa99/ quad
      common /rr140/ rmsa
      common /rr141/ rmsv
      common /i500/ isn
      common /i502/ isv
      common /i501/ inn
      common /ii50/ ix
c      
      quad(:) = (0.d0,0.d0)
      ii=0
      do 1 i=1,ix
        J=I
        ii=((i*(i-1))/2)+J
        a2 =  aquad*rmsv(i)*rmsv(i)
        quad(ii)=quad(ii)+a2 
 1    continue  
      return
      end
